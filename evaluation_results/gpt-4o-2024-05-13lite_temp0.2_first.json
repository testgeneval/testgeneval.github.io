{"raw_generations": {"sample_67": ["    def test_base_serializer_serialize_not_implemented(self):\n        with self.assertRaises(NotImplementedError):\n            BaseSerializer(\"test\").serialize()\n"], "sample_97": ["def test_label_encoder_fit_transform():\n    le = LabelEncoder()\n    y = [1, 2, 2, 6]\n    transformed_y = le.fit_transform(y)\n    assert_array_equal(transformed_y, np.array([0, 1, 1, 2]))\n    assert_array_equal(le.classes_, np.array([1, 2, 6]))\n\n    y = [\"paris\", \"paris\", \"tokyo\", \"amsterdam\"]\n    transformed_y = le.fit_transform(y)\n    assert_array_equal(transformed_y, np.array([1, 1, 2, 0]))\n    assert_array_equal(le.classes_, np.array([\"amsterdam\", \"paris\", \"tokyo\"]))\n"], "sample_37": ["    def test_q_object_combination(self):\n        q1 = Q(a=1)\n        q2 = Q(b=2)\n        combined_q = q1 & q2\n        self.assertEqual(combined_q.connector, Q.AND)\n        self.assertIn(('a', 1), combined_q.children)\n        self.assertIn(('b', 2), combined_q.children)\n"], "sample_7": ["    def test_common_roots_single_path(self):\n        paths = [Path('/a/b/c')]\n        self.assertEqual(autoreload.common_roots(paths), (Path('/a/b/c'),))\n"], "sample_129": ["def test_latex_Derivative():\n    from sympy import Derivative\n    expr = Derivative(x**2 + x*y, x)\n    assert latex(expr) == r'\\frac{d}{d x} \\left(x^{2} + x y\\right)'\n    expr = Derivative(x**2 + x*y, x, y)\n    assert latex(expr) == r'\\frac{\\partial^{2}}{\\partial y \\partial x} \\left(x^{2} + x y\\right)'\n    expr = Derivative(x**2 + x*y, x, x, y)\n    assert latex(expr) == r'\\frac{\\partial^{3}}{\\partial y \\partial x^{2}} \\left(x^{2} + x y\\right)'\n    expr = Derivative(x**2 + x*y, x, y, y)\n    assert latex(expr) == r'\\frac{\\partial^{3}}{\\partial y^{2} \\partial x} \\left(x^{2} + x y\\right)'\n"], "sample_44": ["    def test_model_to_dict_with_fields(self):\n        article = Article.objects.create(\n            title='Test Article',\n            content='This is a test article.',\n            published_date=datetime.date.today()\n        )\n        data = model_to_dict(article, fields=['title', 'content'])\n        self.assertEqual(data, {'title': 'Test Article', 'content': 'This is a test article.'})\n"], "sample_150": ["def test_solve_poly_system():\n    # Test solving a simple polynomial system\n    result = solve_poly_system([x*y - 2*y, 2*y**2 - x**2], x, y)\n    expected = [(0, 0), (2, -sqrt(2)), (2, sqrt(2))]\n    assert result == expected\n\n    # Test solving a more complex polynomial system\n    result = solve_poly_system([x**2 + y**2 - 1, x**2 - y**2 - 1], x, y)\n    expected = [(sqrt(2)/2, -sqrt(2)/2), (sqrt(2)/2, sqrt(2)/2), (-sqrt(2)/2, -sqrt(2)/2), (-sqrt(2)/2, sqrt(2)/2)]\n    assert result == expected\n\n    # Test solving a system with no solutions\n    result = solve_poly_system([x**2 + y**2 + 1, x**2 + y**2 - 1], x, y)\n    assert result == []\n\n    # Test solving a system with a single solution\n    result = solve_poly_system([x - y, x + y - 2], x, y)\n    expected = [(1, 1)]\n    assert result == expected\n\n    # Test exception handling for non-polynomial input\n    with raises(ComputationFailed):\n        solve_poly_system([x + y - 1, x**2 + y**2 - 1, x**3 + y**3 - 1], x, y, domain='ZZ')\n"], "sample_84": ["def test_pyobj_property():\n    class DummyNode:\n            return None\n\n    class DummyClass(DummyNode):\n        pyobj = pyobj_property(\"DummyClass\")\n\n    dummy_instance = DummyClass()\n    assert dummy_instance.pyobj is None\n"], "sample_134": ["def test_numpy_printer_codegen_array_contraction():\n    cgac = CodegenArrayContraction(\n        CodegenArrayTensorProduct(\n            MatrixSymbol('A', 3, 3),\n            MatrixSymbol('B', 3, 3)\n        ),\n        (0, 1)\n    )\n    printer = NumPyPrinter()\n    code = printer.doprint(cgac)\n    expected = \"numpy.einsum(A, [0, 1], B, [0, 1])\"\n    assert code == expected\n"], "sample_60": ["    def test_datetime_serializer(self):\n        value = datetime.datetime(2023, 10, 1, 12, 0, 0)\n        serializer = DatetimeDatetimeSerializer(value)\n        serialized_value, imports = serializer.serialize()\n        self.assertEqual(serialized_value, repr(value))\n        self.assertEqual(imports, {\"import datetime\"})\n"], "sample_47": ["    def test_migration_plan_with_clean_start(self):\n        \"\"\"\n        Test the migration_plan method with clean_start=True.\n        \"\"\"\n        executor = MigrationExecutor(connection)\n        targets = [(\"migrations\", \"0001_initial\")]\n        plan = executor.migration_plan(targets, clean_start=True)\n        self.assertEqual(len(plan), 1)\n        self.assertEqual(plan[0][0].name, \"0001_initial\")\n        self.assertFalse(plan[0][1])  # Should be a forward migration\n"], "sample_145": ["def test_latex_escape():\n    assert latex_escape(r'\\textbackslash') == r'\\textbackslash'\n    assert latex_escape('&') == r'\\&'\n    assert latex_escape('%') == r'\\%'\n    assert latex_escape('$') == r'\\$'\n    assert latex_escape('#') == r'\\#'\n    assert latex_escape('_') == r'\\_'\n    assert latex_escape('{') == r'\\{'\n    assert latex_escape('}') == r'\\}'\n    assert latex_escape('~') == r'\\textasciitilde'\n    assert latex_escape('^') == r'\\textasciicircum'\n    assert latex_escape(r'normal\\textbackslash') == r'normal\\textbackslash'\n    assert latex_escape(r'normal&text') == r'normal\\&text'\n    assert latex_escape(r'normal%text') == r'normal\\%text'\n    assert latex_escape(r'normal$text') == r'normal\\$text'\n    assert latex_escape(r'normal#text') == r'normal\\#text'\n    assert latex_escape(r'normal_text') == r'normal\\_text'\n    assert latex_escape(r'normal{text') == r'normal\\{text'\n    assert latex_escape(r'normal}text') == r'normal\\}text'\n    assert latex_escape(r'normal~text') == r'normal\\textasciitilde text'\n    assert latex_escape(r'normal^text') == r'normal\\textasciicircum text'\n"], "sample_10": ["    def test_exact_lookup(self):\n        # Test Exact lookup\n        articles = Article.objects.filter(headline__exact='Article 1')\n        self.assertEqual(list(articles), [self.a1])\n"], "sample_61": ["    def test_format_with_decimal(self):\n        number = Decimal(\"12345.6789\")\n        result = nformat(number, decimal_sep=\".\", decimal_pos=2, grouping=3, thousand_sep=\",\")\n        self.assertEqual(result, \"12,345.67\")\n"], "sample_9": ["    def test_common_roots_single_path(self):\n        paths = [Path('/a/b/c')]\n        expected_roots = (Path('/a/b/c'),)\n        self.assertEqual(autoreload.common_roots(paths), expected_roots)\n"], "sample_53": ["    def test_generate_altered_db_table(self):\n        \"\"\"\n        Test that generate_altered_db_table correctly generates an AlterModelTable\n        operation when the db_table option changes.\n        \"\"\"\n        before_state = self.make_project_state([self.author_with_db_table_options])\n        after_state = self.make_project_state([self.author_with_new_db_table_options])\n        changes = self.get_changes(before_state, after_state)\n        self.assertNumberMigrations(changes, \"testapp\", 1)\n        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTable\"])\n        self.assertOperationAttributes(\n            changes,\n            \"testapp\",\n            0,\n            0,\n            name=\"Author\",\n            table=\"author_two\",\n        )\n"], "sample_146": ["def test_StrPrinter():\n    assert sstr(Add(x, y)) == \"x + y\"\n    assert sstr(Mul(x, y)) == \"x*y\"\n    assert sstr(Pow(x, 2)) == \"x**2\"\n    assert sstr(Pow(x, Rational(1, 2))) == \"sqrt(x)\"\n    assert sstr(Pow(x, -Rational(1, 2))) == \"1/sqrt(x)\"\n    assert sstr(Pow(x, -1)) == \"1/x\"\n    assert sstr(Pow(x, y)) == \"x**y\"\n    assert sstr(Abs(x)) == \"Abs(x)\"\n    assert sstr(Catalan) == \"Catalan\"\n    assert sstr(E) == \"E\"\n    assert sstr(EulerGamma) == \"EulerGamma\"\n    assert sstr(GoldenRatio) == \"GoldenRatio\"\n    assert sstr(TribonacciConstant) == \"TribonacciConstant\"\n    assert sstr(I) == \"I\"\n    assert sstr(oo) == \"oo\"\n    assert sstr(zoo) == \"zoo\"\n    assert sstr(nan) == \"nan\"\n    assert sstr(-oo) == \"-oo\"\n    assert sstr(pi) == \"pi\"\n    assert sstr(Interval(1, 2)) == \"Interval(1, 2)\"\n    assert sstr(Interval(1, 2, True, True)) == \"Interval.open(1, 2)\"\n    assert sstr(Interval(1, 2, True, False)) == \"Interval.Lopen(1, 2)\"\n    assert sstr(Interval(1, 2, False, True)) == \"Interval.Ropen(1, 2)\"\n    assert sstr(AccumBounds(1, 2)) == \"AccumBounds(1, 2)\"\n    assert sstr(Integral(x, (x, 1, 2))) == \"Integral(x, (x, 1, 2))\"\n    assert sstr(Lambda(x, x + 1)) == \"Lambda(x, x + 1)\"\n    assert sstr(Limit(x, x, 0)) == \"Limit(x, x, 0)\"\n    assert sstr(Limit(x, x, 0, dir='-')) == \"Limit(x, x, 0, dir='-')\"\n    assert sstr(Matrix"], "sample_3": ["def test_arith_oper():\n    # Test arithmetic operations which should always return nonseparable output\n    with pytest.raises(ModelDefinitionError):\n        _arith_oper(sh1, rot)  # Different n_inputs and n_outputs\n\n    result = _arith_oper(sh1, sh2)\n    expected = np.ones((sh1.n_outputs, sh1.n_inputs))\n    assert_allclose(result, expected)\n\n    result = _arith_oper(scl1, scl2)\n    expected = np.ones((scl1.n_outputs, scl1.n_inputs))\n    assert_allclose(result, expected)\n"], "sample_8": ["    def test_cleanse_setting_with_sensitive_key(self):\n        self.assertEqual(cleanse_setting('API_KEY', '12345'), CLEANSED_SUBSTITUTE)\n"], "sample_133": ["def test_codegen_with_multiple_return_values():\n    x, y, z = symbols('x y z')\n    expr1 = x + y\n    expr2 = x * y\n    expr3 = x - y\n    expr4 = x / y\n    name_expr = [(\"func1\", expr1), (\"func2\", expr2), (\"func3\", expr3), (\"func4\", expr4)]\n    [(c_name, c_code), (h_name, c_header)] = codegen(name_expr, \"C99\", \"test_multiple\", header=False, empty=False)\n    \n    assert c_name == \"test_multiple.c\"\n    assert h_name == \"test_multiple.h\"\n    \n    expected_c_code = \"\"\"#include \"test_multiple.h\""], "sample_105": ["def test_voting_classifier_hard_voting():\n    clf1 = LogisticRegression(solver='lbfgs', multi_class='multinomial', random_state=1)\n    clf2 = RandomForestClassifier(n_estimators=50, random_state=1)\n    clf3 = GaussianNB()\n    \n    eclf = VotingClassifier(estimators=[('lr', clf1), ('rf', clf2), ('gnb', clf3)], voting='hard')\n    eclf.fit(X, y)\n    \n    # Check if the predictions are consistent\n    predictions = eclf.predict(X)\n    assert_array_equal(predictions, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "], "sample_59": ["    def test_management_form_initialization(self):\n        form = ManagementForm(\n            initial={\n                TOTAL_FORM_COUNT: 5,\n                INITIAL_FORM_COUNT: 2,\n                MIN_NUM_FORM_COUNT: 1,\n                MAX_NUM_FORM_COUNT: 10,\n            }\n        )\n        self.assertEqual(form.initial[TOTAL_FORM_COUNT], 5)\n        self.assertEqual(form.initial[INITIAL_FORM_COUNT], 2)\n        self.assertEqual(form.initial[MIN_NUM_FORM_COUNT], 1)\n        self.assertEqual(form.initial[MAX_NUM_FORM_COUNT], 10)\n"], "sample_123": ["def test_comp():\n    assert comp(1, 1) is True\n    assert comp(1, 2) is False\n    assert comp(1.0, 1.0) is True\n    assert comp(1.0, 1.1) is False\n    assert comp(1.0, 1.0000000001, tol=1e-9) is True\n    assert comp(1.0, 1.0000000001, tol=1e-10) is False\n    assert comp(0, 0) is True\n    assert comp(0, 1) is False\n    assert comp(1, 0) is False\n    assert comp(1, '1') is True\n    assert comp(1, '2') is False\n    assert comp(1.0, '1.0') is True\n    assert comp(1.0, '1.1') is False\n    assert comp(Float('1.0'), '1.0') is True\n    assert comp(Float('1.0'), '1.1') is False\n    assert comp(Float('1.0'), '1.0000000001', tol=1e-9) is True\n    assert comp(Float('1.0'), '1.0000000001', tol=1e-10) is False\n    raises(ValueError, lambda: comp('1', 1))\n    raises(ValueError, lambda: comp(1, '1.0'))\n"], "sample_141": ["def test_convert_to():\n    from sympy.physics.units import meter, second, kilogram, newton, speed_of_light, hbar, gravitational_constant, atomic_mass_constant, mile, kilometer, centimeter, gram\n\n    # Test conversion to single unit\n    assert convert_to(mile, kilometer) == 25146 * kilometer / 15625\n    assert convert_to(mile, kilometer).n() == 1.609344 * kilometer\n    assert convert_to(speed_of_light, meter / second) == 299792458 * meter / second\n    assert convert_to(day, second) == 86400 * second\n    assert convert_to(3 * newton, kilogram * meter / second**2) == 3 * kilogram * meter / second**2\n    assert convert_to(atomic_mass_constant, gram) == 1.660539060e-24 * gram\n\n    # Test conversion to multiple units\n    assert convert_to(speed_of_light, [meter, second]) == 299792458 * meter / second\n    assert convert_to(3 * newton, [centimeter, gram, second]) == 300000 * centimeter * gram / second**2\n\n    # Test conversion to Planck units\n    assert convert_to(atomic_mass_constant, [gravitational_constant, speed_of_light, hbar]).n() == 7.62963085040767e-20 * gravitational_constant**(-0.5) * hbar**0.5 * speed_of_light**0.5\n"], "sample_140": ["def test_point_initialization():\n    p = Point('P')\n    assert p.name == 'P'\n    assert p._pos_dict == {}\n    assert p._vel_dict == {}\n    assert p._acc_dict == {}\n"], "sample_38": ["    def test_read_only_password_hash_field(self):\n        user = User.objects.create_user(username='testuser', password='password')\n        form = UserChangeForm(instance=user)\n        self.assertIn('password', form.fields)\n        self.assertIsInstance(form.fields['password'], ReadOnlyPasswordHashField)\n        self.assertTrue(form.fields['password'].disabled)\n"], "sample_28": ["    def setUp(self):\n        self.site = admin.AdminSite(name=\"test_adminsite\")\n        self.model = User\n"], "sample_20": ["    def test_modelbase_new_class_creation(self):\n        class Meta:\n            pass\n\n        class TestModel(metaclass=ModelBase):\n            Meta = Meta\n\n        self.assertTrue(hasattr(TestModel, '_meta'))\n        self.assertTrue(hasattr(TestModel, 'DoesNotExist'))\n        self.assertTrue(hasattr(TestModel, 'MultipleObjectsReturned'))\n"], "sample_98": ["def test_check_array_force_all_finite():\n    # Test check_array with force_all_finite parameter\n    X = np.array([[1, 2], [3, 4]], dtype=np.float64)\n    assert_array_equal(check_array(X, force_all_finite=True), X)\n    \n    X_nan = np.array([[1, 2], [3, np.nan]], dtype=np.float64)\n    with assert_raises(ValueError):\n        check_array(X_nan, force_all_finite=True)\n    \n    assert_array_equal(check_array(X_nan, force_all_finite='allow-nan'), X_nan)\n    \n    X_inf = np.array([[1, 2], [3, np.inf]], dtype=np.float64)\n    with assert_raises(ValueError):\n        check_array(X_inf, force_all_finite=True)\n    \n    assert_array_equal(check_array(X_inf, force_all_finite=False), X_inf)\n"], "sample_45": ["    def test_classonlymethod(self):\n        class TestClass:\n            @classonlymethod\n                return \"class method called\"\n\n        self.assertEqual(TestClass.test_method(), \"class method called\")\n        with self.assertRaises(AttributeError):\n            TestClass().test_method()\n"], "sample_11": ["    def test_base_serializer_not_implemented(self):\n        with self.assertRaises(NotImplementedError):\n            BaseSerializer(None).serialize()\n"], "sample_104": ["def test_estimator_pretty_printer_with_changed_params():\n    set_config(print_changed_only=True)\n    lr = LogisticRegression(C=0.5, max_iter=200)\n    pp = _EstimatorPrettyPrinter()\n    result = pp.pformat(lr)\n    expected = \"LogisticRegression(C=0.5, max_iter=200)\"\n    assert result == expected, f\"Expected: {expected}, but got: {result}\"\n"], "sample_107": ["def test_logistic_regression_path():\n    X, y = make_classification(n_samples=100, n_features=20, n_classes=2, random_state=42)\n    Cs = [0.1, 1, 10]\n    coefs, Cs, n_iter = logistic_regression_path(X, y, Cs=Cs, solver='lbfgs', max_iter=100)\n\n    assert_equal(len(coefs), len(Cs))\n    assert_equal(len(n_iter), len(Cs))\n    assert_array_equal(Cs, [0.1, 1, 10])\n    assert all(n > 0 for n in n_iter)\n\n    # Check that coefficients change with different regularization strengths\n    assert np.any(np.diff(coefs, axis=0))\n\n    # Check that the logistic regression path converges to a solution\n    for coef in coefs:\n        assert np.all(np.isfinite(coef))\n"], "sample_49": ["    def test_template_changed_resets_loaders(self):\n        file_path = EXTRA_TEMPLATES_DIR / 'test_template.html'\n        with mock.patch('django.template.autoreload.get_template_directories', return_value={EXTRA_TEMPLATES_DIR}):\n            with mock.patch('django.template.autoreload.reset_loaders') as mock_reset_loaders:\n                autoreload.template_changed(sender=None, file_path=file_path)\n                mock_reset_loaders.assert_called_once()\n"], "sample_5": ["    def test_protect_on_delete(self):\n        \"\"\"\n        Test that the PROTECT on_delete handler raises a ProtectedError when\n        trying to delete an object that is referenced by a protected foreign key.\n        \"\"\"\n        parent = Parent.objects.create(name=\"parent\")\n        child = Child.objects.create(name=\"child\", parent=parent)\n        \n        collector = Collector(using='default')\n        collector.collect([parent])\n        \n        with self.assertRaises(ProtectedError) as cm:\n            collector.delete()\n        \n        self.assertIn(\"Cannot delete some instances of model 'Parent'\", str(cm.exception))\n        self.assertIn(\"because they are referenced through a protected foreign key\", str(cm.exception))\n        self.assertIn(\"Child.parent\", str(cm.exception))\n"], "sample_156": ["def test_parse_mathematica_basic():\n    expr = parse_mathematica(\"Sin[x]^2 + Cos[y]^2\")\n    expected = sin(x)**2 + cos(y)**2\n    assert expr == expected\n"], "sample_158": ["def test_unit_system_initialization():\n    base_units = (meter, second, kilogram)\n    units = (joule, volt)\n    name = \"TestSystem\"\n    descr = \"A test unit system\"\n    dimension_system = SI.get_dimension_system()\n    derived_units = {energy: joule, pressure: pascal}\n\n    us = UnitSystem(base_units, units, name, descr, dimension_system, derived_units)\n\n    assert us.name == name\n    assert us.descr == descr\n    assert us._base_units == base_units\n    assert us._units == tuple(set(base_units) | set(units))\n    assert us._dimension_system == dimension_system\n    assert us._derived_units == derived_units\n    assert UnitSystem._unit_systems[name] == us\n"], "sample_55": ["    def test_command_error(self):\n        with self.assertRaises(CommandError) as cm:\n            raise CommandError(\"This is a command error\", returncode=2)\n        self.assertEqual(cm.exception.returncode, 2)\n        self.assertEqual(str(cm.exception), \"This is a command error\")\n"], "sample_95": ["    def test_pytest_addoption(self, pytester: Pytester):\n        pytester.makeconftest(\n            \"\"\"\n                parser.addoption(\"--foo\", action=\"store_true\", help=\"foo option\")\n            \"\"\"\n        )\n        result = pytester.runpytest(\"--help\")\n        result.stdout.fnmatch_lines([\"--foo          foo option\"])\n"], "sample_30": ["    def test_formfield_for_dbfield_with_choices(self):\n        \"\"\"\n        Test that formfield_for_dbfield returns the correct form field\n        for a database field with choices.\n        \"\"\"\n        class TestModel(models.Model):\n            CHOICES = (\n                ('A', 'Choice A'),\n                ('B', 'Choice B'),\n            )\n            choice_field = models.CharField(max_length=1, choices=CHOICES)\n\n        class TestModelAdmin(ModelAdmin):\n            model = TestModel\n\n        model_admin = TestModelAdmin(TestModel, admin_site)\n        request = self.factory.get('/admin/')\n        form_field = model_admin.formfield_for_dbfield(TestModel._meta.get_field('choice_field'), request)\n        self.assertIsInstance(form_field.widget, widgets.AdminRadioSelect)\n        self.assertEqual(form_field.choices, [('A', 'Choice A'), ('B', 'Choice B')])\n"], "sample_34": ["    def test_modelbase_new_with_no_parents(self):\n        class NoParentModel(metaclass=ModelBase):\n            pass\n\n        self.assertTrue(issubclass(NoParentModel, models.Model))\n"], "sample_106": ["def test_nca_fit_transform():\n    # Test the fit and transform methods of NCA\n    nca = NeighborhoodComponentsAnalysis(n_components=2, random_state=42)\n    X_transformed = nca.fit_transform(iris_data, iris_target)\n    \n    # Check the shape of the transformed data\n    assert_equal(X_transformed.shape, (iris_data.shape[0], 2))\n    \n    # Check if the transformation is consistent with separate fit and transform calls\n    nca.fit(iris_data, iris_target)\n    X_transformed_separate = nca.transform(iris_data)\n    assert_array_almost_equal(X_transformed, X_transformed_separate)\n"], "sample_90": ["    def test_mark_evaluator_istrue_with_condition(self):\n        item = mock.Mock()\n        item.iter_markers.return_value = [Mark(name=\"mark\", args=(\"os.name == 'posix'\",), kwargs={})]\n        evaluator = MarkEvaluator(item, \"mark\")\n        assert evaluator.istrue() is True\n        assert evaluator.wasvalid() is True\n"], "sample_74": ["def test_colorbar_set_ticks():\n    fig, ax = plt.subplots()\n    cmap = mpl.colormaps[\"viridis\"]\n    norm = Normalize(vmin=0, vmax=1)\n    cbar = Colorbar(ax, cmap=cmap, norm=norm, orientation='vertical')\n    \n    # Set major ticks\n    cbar.set_ticks([0.2, 0.4, 0.6, 0.8])\n    assert np.allclose(cbar.get_ticks(), [0.2, 0.4, 0.6, 0.8])\n    \n    # Set minor ticks\n    cbar.set_ticks([0.1, 0.3, 0.5, 0.7, 0.9], minor=True)\n    assert np.allclose(cbar.get_ticks(minor=True), [0.1, 0.3, 0.5, 0.7, 0.9])\n    \n    # Set tick labels\n    cbar.set_ticklabels(['A', 'B', 'C', 'D'])\n    assert [label.get_text() for label in cbar.ax.get_yticklabels()] == ['A', 'B', 'C', 'D']\n"], "sample_85": ["def test_colored_level_formatter():\n    from _pytest.config import create_terminal_writer\n    from _pytest.logging import ColoredLevelFormatter\n    import logging\n\n    class MockTerminalWriter:\n            return text\n\n    terminal_writer = MockTerminalWriter()\n    formatter = ColoredLevelFormatter(terminal_writer, \"%(levelname)s: %(message)s\")\n\n    logger = logging.getLogger(\"test_logger\")\n    logger.setLevel(logging.DEBUG)\n    handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    with pytest.raises(ValueError):\n        logger.log(100, \"This is a critical message\")\n\n    logger.debug(\"This is a debug message\")\n    logger.info(\"This is an info message\")\n    logger.warning(\"This is a warning message\")\n    logger.error(\"This is an error message\")\n    logger.critical(\"This is a critical message\")\n"], "sample_132": ["def test_are_coplanar():\n    from sympy.geometry import Point3D, Line3D, Plane\n\n    # Test with points\n    a = Point3D(1, 2, 3)\n    b = Point3D(4, 5, 6)\n    c = Point3D(7, 8, 9)\n    d = Point3D(1, 1, 1)\n    assert are_coplanar(a, b, c) is False\n    assert are_coplanar(a, b, d) is True\n\n    # Test with lines\n    l1 = Line3D(Point3D(0, 0, 0), Point3D(1, 1, 1))\n    l2 = Line3D(Point3D(1, 0, 0), Point3D(0, 1, 1))\n    l3 = Line3D(Point3D(0, 1, 0), Point3D(1, 0, 1))\n    assert are_coplanar(l1, l2, l3) is False\n\n    # Test with planes\n    p1 = Plane(Point3D(0, 0, 0), normal_vector=(1, 1, 1))\n    p2 = Plane(Point3D(1, 1, 1), normal_vector=(1, -1, 1))\n    assert are_coplanar(p1, l1, l2) is True\n    assert are_coplanar(p1, l1, l3) is False\n\n    # Test with mixed entities\n    assert are_coplanar(a, l1, p1) is True\n    assert are_coplanar(a, l1, p2) is False\n\n    # Test with insufficient points\n    assert are_coplanar(a, b) is False\n"], "sample_27": ["    def test_make_token(self):\n        user = User.objects.create_user(username='testuser', password='password123')\n        token_generator = PasswordResetTokenGenerator()\n        token = token_generator.make_token(user)\n        self.assertIsNotNone(token)\n        self.assertIn('-', token)\n        ts_b36, hash_string = token.split('-')\n        self.assertEqual(len(hash_string), 20)\n        self.assertTrue(ts_b36.isalnum())\n"], "sample_39": ["    def test_resolver_match_repr(self):\n        func = views.empty_view\n        args = ('42', '37')\n        kwargs = {'arg1': '42', 'arg2': '37'}\n        url_name = 'test-view'\n        app_names = ['app1', 'app2']\n        namespaces = ['ns1', 'ns2']\n        route = '/test/42/37/'\n        resolver_match = ResolverMatch(func, args, kwargs, url_name, app_names, namespaces, route)\n        \n        expected_repr = (\n            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, args=('42', '37'), kwargs={'arg1': '42', 'arg2': '37'}, \"\n            \"url_name='test-view', app_names=['app1', 'app2'], namespaces=['ns1', 'ns2'], route='/test/42/37/')\"\n        )\n        self.assertEqual(repr(resolver_match), expected_repr)\n"], "sample_35": ["    def test_model_form_options_initialization(self):\n        class Meta:\n            model = ChoiceModel\n            fields = ['field1', 'field2']\n            exclude = ['field3']\n            widgets = {'field1': 'widget1'}\n            localized_fields = ['field1']\n            labels = {'field1': 'Label 1'}\n            help_texts = {'field1': 'Help text 1'}\n            error_messages = {'field1': {'required': 'This field is required.'}}\n            field_classes = {'field1': CharField}\n\n        options = ModelFormOptions(Meta)\n        self.assertEqual(options.model, ChoiceModel)\n        self.assertEqual(options.fields, ['field1', 'field2'])\n        self.assertEqual(options.exclude, ['field3'])\n        self.assertEqual(options.widgets, {'field1': 'widget1'})\n        self.assertEqual(options.localized_fields, ['field1'])\n        self.assertEqual(options.labels, {'field1': 'Label 1'})\n        self.assertEqual(options.help_texts, {'field1': 'Help text 1'})\n        self.assertEqual(options.error_messages, {'field1': {'required': 'This field is required.'}})\n        self.assertEqual(options.field_classes, {'field1': CharField})\n"], "sample_144": ["def test_refine_abs():\n    assert refine(Abs(x), Q.real(x)) == Abs(x)\n    assert refine(Abs(x), Q.positive(x)) == x\n    assert refine(Abs(x), Q.negative(x)) == -x\n    assert refine(Abs(x*y), Q.positive(x) & Q.positive(y)) == x*y\n    assert refine(Abs(x*y), Q.negative(x) & Q.negative(y)) == x*y\n    assert refine(Abs(x*y), Q.positive(x) & Q.negative(y)) == -x*y\n    assert refine(Abs(x*y), Q.negative(x) & Q.positive(y)) == -x*y\n"], "sample_31": ["    def test_python_shell(self, mock_interact):\n        call_command('shell', interface='python')\n        mock_interact.assert_called_once()\n"], "sample_64": ["    def test_prepopulated_fields_js(self):\n        class MockField:\n                self.name = name\n                self.auto_id = auto_id\n                self.field = self\n                self.max_length = max_length\n                self.allow_unicode = allow_unicode\n\n        class MockAdminForm:\n                self.prepopulated_fields = prepopulated_fields\n\n        context = {\n            \"adminform\": MockAdminForm([\n                {\"field\": MockField(\"field1\", \"id_field1\"), \"dependencies\": [MockField(\"dep1\", \"id_dep1\")]}\n            ]),\n            \"inline_admin_formsets\": []\n        }\n\n        result = prepopulated_fields_js(context)\n        self.assertIn(\"prepopulated_fields\", result)\n        self.assertIn(\"prepopulated_fields_json\", result)\n        self.assertEqual(len(result[\"prepopulated_fields\"]), 1)\n        self.assertEqual(json.loads(result[\"prepopulated_fields_json\"])[0][\"id\"], \"#id_field1\")\n        self.assertEqual(json.loads(result[\"prepopulated_fields_json\"])[0][\"dependency_ids\"], [\"#id_dep1\"])\n"], "sample_86": ["    def test_record_property(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n                record_property(\"key1\", \"value1\")\n                record_property(\"key2\", \"value2\")\n\n                pass\n            \"\"\"\n        )\n        result, dom = runandparse(testdir)\n        assert result.ret == 0\n        testcase = dom.find_first_by_tag(\"testcase\")\n        properties = testcase.find_first_by_tag(\"properties\")\n        assert properties is not None\n        property_nodes = properties.find_by_tag(\"property\")\n        assert len(property_nodes) == 2\n        property_nodes[0].assert_attr(name=\"key1\", value=\"value1\")\n        property_nodes[1].assert_attr(name=\"key2\", value=\"value2\")\n"], "sample_76": ["    def polyfit(self):\n        return PolyFit(order=2, gridsize=100)\n"], "sample_19": ["    def setUp(self):\n        self.filter = SafeExceptionReporterFilter()\n"], "sample_118": ["def test_ccode_known_functions():\n    assert ccode(sin(x)) == \"sin(x)\"\n    assert ccode(cos(x)) == \"cos(x)\"\n    assert ccode(tan(x)) == \"tan(x)\"\n    assert ccode(asin(x)) == \"asin(x)\"\n    assert ccode(acos(x)) == \"acos(x)\"\n    assert ccode(atan(x)) == \"atan(x)\"\n    assert ccode(exp(x)) == \"exp(x)\"\n    assert ccode(log(x)) == \"log(x)\"\n    assert ccode(erf(x)) == \"erf(x)\"\n    assert ccode(sinh(x)) == \"sinh(x)\"\n    assert ccode(cosh(x)) == \"cosh(x)\"\n    assert ccode(tanh(x)) == \"tanh(x)\"\n    assert ccode(asinh(x)) == \"asinh(x)\"\n    assert ccode(acosh(x)) == \"acosh(x)\"\n    assert ccode(atanh(x)) == \"atanh(x)\"\n    assert ccode(Abs(x)) == \"fabs(x)\"\n    assert ccode(gamma(x)) == \"tgamma(x)\"\n    assert ccode(ceiling(x)) == \"ceil(x)\"\n    assert ccode(floor(x)) == \"floor(x)\"\n"], "sample_152": ["def test_ndimarray_addition():\n    for cls in array_types:\n        a = cls([1, 2, 3, 4], (2, 2))\n        b = cls([4, 3, 2, 1], (2, 2))\n        c = a + b\n        assert c.tolist() == [[5, 5], [5, 5]]\n\n        with raises(ValueError):\n            a + cls([1, 2, 3], (3,))\n"], "sample_143": ["def test_prettyprinter_imaginary_unit():\n    # Test for imaginary unit setting\n    expr = I\n    assert pretty(expr) == 'I'\n    assert upretty(expr) == '\u2148'\n\n    pp = PrettyPrinter({'imaginary_unit': 'j'})\n    assert pp.doprint(expr) == 'j'\n\n    pp = PrettyPrinter({'imaginary_unit': 'i'})\n    assert pp.doprint(expr) == '\u2148'\n\n    raises(TypeError, lambda: PrettyPrinter({'imaginary_unit': 1}))\n    raises(ValueError, lambda: PrettyPrinter({'imaginary_unit': 'k'}))\n"], "sample_154": ["def test_lambdify_with_custom_function():\n    # Define a custom function\n    custom_func = implemented_function('custom_func', lambda x: x**2 + 1)\n    \n    # Create a SymPy expression using the custom function\n    expr = custom_func(x)\n    \n    # Lambdify the expression\n    f = lambdify(x, expr)\n    \n    # Test the lambdified function\n    assert f(2) == 5\n    assert f(3) == 10\n    assert f(-1) == 2\n\n    # Test with numpy array\n    if numpy:\n        import numpy as np\n        a = np.array([1, 2, 3])\n        np.testing.assert_array_equal(f(a), a**2 + 1)\n\n    # Test with tensorflow tensor\n    if tensorflow:\n        import tensorflow as tf\n        tf_a = tf.constant([1.0, 2.0, 3.0])\n        tf_result = f(tf_a)\n        np.testing.assert_array_equal(tf_result.numpy(), np.array([2.0, 5.0, 10.0]))\n"], "sample_51": ["compilation error"], "sample_17": ["    def test_create_test_db(self, mock_nodb_cursor, mock_call_command):\n        test_connection = get_connection_copy()\n        creation = BaseDatabaseCreation(test_connection)\n        mock_cursor = mock.Mock()\n        mock_nodb_cursor.return_value.__enter__.return_value = mock_cursor\n\n        test_connection.settings_dict['TEST'] = {\n            'NAME': None,\n            'MIGRATE': True\n        }\n        test_connection.settings_dict['NAME'] = 'default_db'\n\n        test_db_name = creation.create_test_db(verbosity=1, autoclobber=True, serialize=True, keepdb=False)\n\n        self.assertEqual(test_db_name, 'test_default_db')\n        self.assertEqual(test_connection.settings_dict['NAME'], 'test_default_db')\n        self.assertTrue(mock_call_command.called)\n        mock_cursor.execute.assert_any_call('CREATE DATABASE \"test_default_db\" ')\n"], "sample_48": ["    def test_create_model(self):\n        \"\"\"\n        Test the CreateModel operation.\n        \"\"\"\n        project_state = ProjectState()\n        operation = migrations.CreateModel(\n            name='TestModel',\n            fields=[\n                ('id', models.AutoField(primary_key=True)),\n                ('name', models.CharField(max_length=255)),\n            ],\n            options={\n                'ordering': ['name'],\n            },\n            bases=(Mixin,),\n            managers=[\n                ('food_manager', FoodManager()),\n            ],\n        )\n        # Test state alteration\n        operation.state_forwards('test_app', project_state)\n        self.assertIn(('test_app', 'testmodel'), project_state.models)\n        model_state = project_state.models['test_app', 'testmodel']\n        self.assertEqual(model_state.name, 'TestModel')\n        self.assertEqual(model_state.fields[0].name, 'id')\n        self.assertEqual(model_state.fields[1].name, 'name')\n        self.assertEqual(model_state.options['ordering'], ['name'])\n        self.assertEqual(model_state.bases, (Mixin,))\n        self.assertEqual(model_state.managers[0].name, 'food_manager')\n\n        # Test database alteration\n        with connection.schema_editor() as editor:\n            operation.database_forwards('test_app', editor, project_state, project_state)\n            self.assertTableExists('test_app_testmodel')\n\n        # Test database rollback\n        with connection.schema_editor() as editor:\n            operation.database_backwards('test_app', editor, project_state, project_state)\n            self.assertTableNotExists('test_app_testmodel')\n"], "sample_124": ["def test_sinh():\n    x = symbols('x')\n    \n    # Basic functionality\n    assert sinh(0) == 0\n    assert sinh(1) == sinh(1)\n    assert sinh(-1) == -sinh(1)\n    assert sinh(I*pi) == 0\n    assert sinh(I*pi/2) == I\n    assert sinh(I*pi/3) == sqrt(3)/2*I\n    assert sinh(I*pi/4) == sqrt(2)/2*I\n    assert sinh(I*pi/6) == 1/2*I\n    \n    # Check evaluation of special values\n    assert sinh(oo) == oo\n    assert sinh(-oo) == -oo\n    assert sinh(nan) == nan\n    assert sinh(zoo) == nan\n    \n    # Check evaluation of inverse hyperbolic functions\n    assert sinh(asinh(x)) == x\n    assert sinh(acosh(x)) == sqrt(x - 1) * sqrt(x + 1)\n    assert sinh(atanh(x)) == x/sqrt(1 - x**2)\n    assert sinh(acoth(x)) == 1/(sqrt(x - 1) * sqrt(x + 1))\n    \n    # Check Taylor series expansion\n    assert sinh(x).series(x, 0, 10) == x + x**3/6 + x**5/120 + x**7/5040 + x**9/362880 + O(x**10)\n    \n    # Check conjugate\n    assert sinh(x).conjugate() == sinh(x.conjugate())\n    \n    # Check as_real_imag\n    assert sinh(x + I*pi/2).as_real_imag() == (I*cos(x), sinh(x))\n    \n    # Check rewrite\n    assert sinh(x).rewrite(exp) == (exp(x) - exp(-x)) / 2\n    assert sinh(x).rewrite(cosh) == -I*cosh(x + I*pi/2)\n    assert sinh(x).rewrite(tanh) == 2*tanh(x/2)/(1 - tanh(x/2)**2)\n    assert sinh(x).rewrite(coth) == 2*coth(x/2)/(coth(x/2)**2 - 1)\n    \n    # Check leading term\n    assert sinh(x).as_leading_term(x) == x\n    \n    # Check is_real\n    assert sinh(x).is_real == x.is_real"], "sample_149": ["def test_monomial_div():\n    assert monomial_div((3, 4, 1), (1, 2, 0)) == (2, 2, 1)\n    assert monomial_div((3, 4, 1), (1, 2, 2)) is None\n    assert monomial_div((5, 5, 5), (5, 5, 5)) == (0, 0, 0)\n    assert monomial_div((0, 0, 0), (1, 1, 1)) is None\n    assert monomial_div((4, 4, 4), (2, 2, 2)) == (2, 2, 2)\n"], "sample_130": ["def test_lambdify_with_custom_function():\n    # Test lambdify with a custom function implementation\n        return x + 1\n\n    f = implemented_function(Function('f'), custom_func)\n    func = lambdify(x, f(x))\n    assert func(4) == 5\n    assert func(10) == 11\n\n    # Test lambdify with a custom function in a more complex expression\n    expr = f(x) + f(y)\n    func = lambdify((x, y), expr)\n    assert func(1, 2) == 5\n    assert func(3, 4) == 9\n\n    # Test lambdify with a custom function and sympy functions\n    expr = f(x) + sin(y)\n    func = lambdify((x, y), expr, \"math\")\n    assert func(1, math.pi/2) == 3\n    assert func(2, math.pi) == 2\n\n    # Test lambdify with a custom function and numpy functions\n    if numpy:\n        expr = f(x) + numpy.sin(y)\n        func = lambdify((x, y), expr, \"numpy\")\n        assert func(1, numpy.pi/2) == 3\n        assert func(2, numpy.pi) == 2\n"], "sample_113": ["def test_column_transformer_with_callable():\n    # Test ColumnTransformer with callable column selection\n    df = np.array([\n        [0, 1, 2, 3],\n        [4, 5, 6, 7],\n        [8, 9, 10, 11]\n    ])\n    \n        return [0, 1]\n\n        return [2, 3]\n\n    ct = ColumnTransformer(\n        [\n            (\"first_two\", StandardScaler(), select_first_two_columns),\n            (\"last_two\", Normalizer(), select_last_two_columns)\n        ]\n    )\n\n    transformed = ct.fit_transform(df)\n    expected = np.hstack([\n        StandardScaler().fit_transform(df[:, [0, 1]]),\n        Normalizer().fit_transform(df[:, [2, 3]])\n    ])\n    \n    assert_allclose(transformed, expected)\n"], "sample_116": ["def test_create_index_single_entry(app):\n    text = \"\"\"\n    .. index:: single: Python\n    \"\"\"\n    app.env.get_doctree('index')  # Ensure the doctree is built\n    index_entries = IndexEntries(app.env)\n    index = index_entries.create_index(app.builder)\n    \n    assert len(index) == 1\n    assert index[0][0] == 'P'\n    assert len(index[0][1]) == 1\n    assert index[0][1][0][0] == 'Python'\n    assert len(index[0][1][0][1]) == 1\n    assert index[0][1][0][1][0][0] == 'main'\n"], "sample_109": ["def test_leave_one_out():\n    \"\"\"Test LeaveOneOut cross-validator\"\"\"\n    loo = LeaveOneOut()\n    X = np.array([[1, 2], [3, 4], [5, 6]])\n    y = np.array([1, 2, 3])\n    \n    splits = list(loo.split(X, y))\n    assert len(splits) == 3, \"There should be 3 splits for 3 samples\"\n    \n    expected_splits = [\n        (np.array([1, 2]), np.array([0])),\n        (np.array([0, 2]), np.array([1])),\n        (np.array([0, 1]), np.array([2]))\n    ]\n    \n    for i, (train_index, test_index) in enumerate(splits):\n        assert_array_equal(train_index, expected_splits[i][0])\n        assert_array_equal(test_index, expected_splits[i][1])\n    \n    assert loo.get_n_splits(X) == 3, \"Number of splits should be equal to number of samples\"\n    \n    with pytest.raises(ValueError):\n        loo.get_n_splits(None)\n"], "sample_40": ["    def test_boundfield_as_widget(self):\n        form = Person()\n        bound_field = BoundField(form, form.fields['first_name'], 'first_name')\n        widget_html = bound_field.as_widget()\n        self.assertIn('input', widget_html)\n        self.assertIn('type=\"text\"', widget_html)\n        self.assertIn('name=\"first_name\"', widget_html)\n"], "sample_128": ["def test_Options_initialization():\n    # Test basic initialization with gens and args\n    opts = Options((x, y, z), {'domain': 'ZZ'})\n    assert opts['gens'] == (x, y, z)\n    assert opts['domain'] == ZZ\n    assert opts['auto'] is False\n\n    # Test initialization with conflicting gens and args\n    raises(OptionError, lambda: Options((x, y), {'gens': (x, y, z)}))\n\n    # Test initialization with defaults\n    opts = Options((x, y), {'domain': 'ZZ'}, strict=True)\n    assert opts['gens'] == (x, y)\n    assert opts['domain'] == ZZ\n    assert opts['strict'] is True\n\n    # Test initialization with flags\n    opts = Options((x, y), {'domain': 'ZZ'}, flags=['auto'])\n    assert opts['auto'] is True\n\n    # Test initialization with invalid option\n    raises(OptionError, lambda: Options((x, y), {'invalid_option': 'value'}))\n\n    # Test initialization with required and excluded options\n    raises(OptionError, lambda: Options((x, y), {'field': True, 'domain': 'ZZ'}))\n    raises(OptionError, lambda: Options((x, y), {'field': True, 'split': True}))\n\n    # Test initialization with required options\n    opts = Options((x, y), {'modulus': 5, 'symmetric': True})\n    assert opts['modulus'] == 5\n    assert opts['symmetric'] is True\n\n    # Test initialization with excluded options\n    raises(OptionError, lambda: Options((x, y), {'modulus': 5, 'domain': 'ZZ'}))\n"], "sample_73": ["def test_offsetbox_contains():\n    fig, ax = plt.subplots()\n    box = OffsetBox()\n    ax.add_artist(box)\n\n    child1 = mpatches.Circle((0.5, 0.5), 0.1)\n    child2 = mpatches.Circle((0.7, 0.7), 0.1)\n    box._children = [child1, child2]\n\n    event_inside = MouseEvent('button_press_event', fig.canvas, 0.5, 0.5, MouseButton.LEFT)\n    event_outside = MouseEvent('button_press_event', fig.canvas, 0.1, 0.1, MouseButton.LEFT)\n\n    assert box.contains(event_inside)[0] is True\n    assert box.contains(event_outside)[0] is False\n"], "sample_111": ["def test_contingency_matrix():\n    # Test contingency matrix with dense output\n    labels_true = [0, 0, 1, 1, 2, 2]\n    labels_pred = [0, 0, 1, 1, 1, 2]\n    expected_dense = np.array([[2, 0, 0],\n                               [0, 2, 0],\n                               [0, 1, 1]])\n    result_dense = contingency_matrix(labels_true, labels_pred, sparse=False)\n    assert_allclose(result_dense, expected_dense)\n\n    # Test contingency matrix with sparse output\n    expected_sparse = sp.csr_matrix(expected_dense)\n    result_sparse = contingency_matrix(labels_true, labels_pred, sparse=True)\n    assert (result_sparse != expected_sparse).nnz == 0\n\n    # Test contingency matrix with eps\n    eps = 0.1\n    expected_dense_eps = expected_dense + eps\n    result_dense_eps = contingency_matrix(labels_true, labels_pred, eps=eps, sparse=False)\n    assert_allclose(result_dense_eps, expected_dense_eps)\n\n    # Test ValueError when both eps and sparse are set\n    with pytest.raises(ValueError):\n        contingency_matrix(labels_true, labels_pred, eps=eps, sparse=True)\n"], "sample_151": ["def test_point_creation():\n    # Test creation of Point2D and Point3D\n    p2d = Point(1, 2)\n    assert isinstance(p2d, Point2D)\n    assert p2d.x == 1\n    assert p2d.y == 2\n\n    p3d = Point(1, 2, 3)\n    assert isinstance(p3d, Point3D)\n    assert p3d.x == 1\n    assert p3d.y == 2\n    assert p3d.z == 3\n\n    # Test creation with list input\n    p2d_list = Point([1, 2])\n    assert isinstance(p2d_list, Point2D)\n    assert p2d_list.x == 1\n    assert p2d_list.y == 2\n\n    p3d_list = Point([1, 2, 3])\n    assert isinstance(p3d_list, Point3D)\n    assert p3d_list.x == 1\n    assert p3d_list.y == 2\n    assert p3d_list.z == 3\n\n    # Test creation with sympy symbols\n    x = Symbol('x')\n    p2d_sym = Point(0, x)\n    assert isinstance(p2d_sym, Point2D)\n    assert p2d_sym.x == 0\n    assert p2d_sym.y == x\n\n    # Test creation with dimension specified\n    p4d = Point(dim=4)\n    assert isinstance(p4d, Point)\n    assert len(p4d) == 4\n    assert all(coord == 0 for coord in p4d)\n\n    # Test creation with floats and evaluate flag\n    p2d_float = Point(0.5, 0.25)\n    assert isinstance(p2d_float, Point2D)\n    assert p2d_float.x == Rational(1, 2)\n    assert p2d_float.y == Rational(1, 4)\n\n    p2d_float_no_eval = Point(0.5, 0.25, evaluate=False)\n    assert isinstance(p2d_float_no_eval, Point2D)\n    assert p2d_float_no_eval.x == 0.5\n    assert p2d_float_no_eval.y == 0.25\n"], "sample_54": ["    def test_escape(self):\n        self.check_output(escape, '<script>alert(\"xss\")</script>', '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;')\n        self.check_output(escape, 'Hello & welcome!', 'Hello &amp; welcome!')\n        self.check_output(escape, '\"double quotes\" and \\'single quotes\\'', '&quot;double quotes&quot; and &#x27;single quotes&#x27;')\n        self.check_output(escape, mark_safe('<b>bold</b>'), '&lt;b&gt;bold&lt;/b&gt;')\n"], "sample_148": ["def test_re_im():\n    x, y = symbols('x y', real=True)\n    z = Symbol('z')\n\n    # Test re function\n    assert re(2*E) == 2*E\n    assert re(2*I + 17) == 17\n    assert re(2*I) == 0\n    assert re(im(x) + x*I + 2) == 2\n    assert re(5 + I + 2) == 7\n    assert re(x + y*I) == x\n    assert re(z).rewrite(im) == z - S.ImaginaryUnit*im(z)\n\n    # Test im function\n    assert im(2*E) == 0\n    assert im(2*I + 17) == 2\n    assert im(x*I) == re(x)\n    assert im(re(x) + y) == im(y)\n    assert im(2 + 3*I) == 3\n    assert im(x + y*I) == y\n    assert im(z).rewrite(re) == -S.ImaginaryUnit*(z - re(z))\n\n    # Test derivatives\n    assert re(x**2).diff(x) == 2*x\n    assert im(x**2).diff(x) == 0\n    assert re(I*x).diff(x) == 0\n    assert im(I*x).diff(x) == 1\n\n    # Test matrix input\n    M = Matrix([[1 + I, 2], [3, 4 + 2*I]])\n    assert re(M) == Matrix([[1, 2], [3, 4]])\n    assert im(M) == Matrix([[1, 0], [0, 2]])\n\n    # Test edge cases\n    assert re(nan) == nan\n    assert im(nan) == nan\n    assert re(zoo) == nan\n    assert im(zoo) == nan\n    assert re(oo) == oo\n    assert im(oo) == 0\n    assert re(-oo) == -oo\n    assert im(-oo) == 0\n"], "sample_155": ["def test_unit_system_initialization():\n    base_units = (meter, second, kilogram)\n    units = (joule, coulomb)\n    name = \"TestSystem\"\n    descr = \"A test unit system\"\n    dimension_system = SI.get_dimension_system()\n    derived_units = {energy: joule}\n\n    us = UnitSystem(base_units, units, name, descr, dimension_system, derived_units)\n\n    assert us.name == name\n    assert us.descr == descr\n    assert us._base_units == base_units\n    assert us._units == tuple(set(base_units) | set(units))\n    assert us._dimension_system == dimension_system\n    assert us._derived_units == derived_units\n    assert UnitSystem._unit_systems[name] == us\n"], "sample_83": ["def test_colorize_ansi():\n    msg = \"Test message\"\n    msg_style = MessageStyle(color=\"red\", style=(\"bold\", \"underline\"))\n    expected_output = \"\\033[1;4;31mTest message\\033[0m\"\n    assert colorize_ansi(msg, msg_style) == expected_output\n\n    msg_style = MessageStyle(color=None, style=())\n    assert colorize_ansi(msg, msg_style) == msg\n\n    msg_style = \"blue\"\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        result = colorize_ansi(msg, msg_style)\n        assert len(w) == 1\n        assert issubclass(w[-1].category, DeprecationWarning)\n        assert \"In pylint 3.0, the colorize_ansi function\" in str(w[-1].message)\n        assert result == \"\\033[34mTest message\\033[0m\"\n"], "sample_43": ["    def test_get_with_valid_request(self):\n        self.client.login(username='user', password='secret')\n        request = self.factory.get(self.url, {\n            'term': 'test',\n            'app_label': 'admin_views',\n            'model_name': 'answer',\n            'field_name': 'question',\n        })\n        request.user = self.user\n        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n        self.assertEqual(response.status_code, 200)\n        content = json.loads(response.content.decode())\n        self.assertIn('results', content)\n        self.assertIn('pagination', content)\n        self.assertIsInstance(content['results'], list)\n        self.assertIsInstance(content['pagination'], dict)\n"], "sample_137": ["def test_is_palindromic():\n    assert is_palindromic([1, 0, 1]) is True\n    assert is_palindromic('abcbb') is False\n    assert is_palindromic('abcbb', 1) is False\n    assert is_palindromic('abcbb', 1, -1) is True\n    assert is_palindromic('abcbb', -4, -1) is True\n    assert is_palindromic([1, 2, 3, 2, 1]) is True\n    assert is_palindromic([1, 2, 3, 4, 5]) is False\n    assert is_palindromic('racecar') is True\n    assert is_palindromic('hello') is False\n    assert is_palindromic('a') is True\n    assert is_palindromic('') is True\n"], "sample_68": ["    def test_bulk_create_with_batch_size(self):\n        batch_size = 2\n        created_countries = Country.objects.bulk_create(self.data, batch_size=batch_size)\n        self.assertEqual(Country.objects.count(), len(self.data))\n        self.assertEqual(len(created_countries), len(self.data))\n        for country in self.data:\n            self.assertTrue(Country.objects.filter(name=country.name).exists())\n"], "sample_119": ["def test_basic_operations():\n    assert mcode(x + y) == 'x + y'\n    assert mcode(x * y) == 'x*y'\n    assert mcode(x - y) == 'x - y'\n    assert mcode(x / y) == 'x/y'\n    assert mcode(x**y) == 'x^y'\n    assert mcode(x**2) == 'x^2'\n    assert mcode(2**x) == '2^x'\n"], "sample_79": ["def test_concat_datasets_with_different_coords():\n    ds1 = Dataset(\n        {\n            \"var1\": (\"x\", [1, 2, 3]),\n            \"var2\": (\"x\", [4, 5, 6]),\n        },\n        coords={\"x\": [0, 1, 2], \"y\": (\"x\", [10, 20, 30])},\n    )\n    ds2 = Dataset(\n        {\n            \"var1\": (\"x\", [7, 8, 9]),\n            \"var2\": (\"x\", [10, 11, 12]),\n        },\n        coords={\"x\": [3, 4, 5], \"y\": (\"x\", [40, 50, 60])},\n    )\n\n    result = concat([ds1, ds2], dim=\"x\", coords=\"different\")\n\n    expected = Dataset(\n        {\n            \"var1\": (\"x\", [1, 2, 3, 7, 8, 9]),\n            \"var2\": (\"x\", [4, 5, 6, 10, 11, 12]),\n        },\n        coords={\"x\": [0, 1, 2, 3, 4, 5], \"y\": (\"x\", [10, 20, 30, 40, 50, 60])},\n    )\n\n    assert_identical(result, expected)\n"], "sample_77": ["    def x(self):\n        return pd.Series([\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"], name=\"x\")\n"], "sample_88": ["def test_saferepr_basic():\n    obj = {\"key\": \"value\", \"another_key\": [1, 2, 3, 4]}\n    result = saferepr(obj, maxsize=50)\n    assert len(result) <= 50\n    assert \"key\" in result\n    assert \"value\" in result\n"], "sample_21": ["    def test_protect_on_delete(self):\n        \"\"\"\n        Test the PROTECT on_delete behavior.\n        \"\"\"\n        parent = Parent.objects.create()\n        child = Child.objects.create(parent=parent)\n        \n        collector = Collector(using='default')\n        collector.collect([parent])\n        \n        with self.assertRaises(ProtectedError) as cm:\n            collector.delete()\n        \n        self.assertIn(\"Cannot delete some instances of model 'Parent' because they are referenced through a protected foreign key\", str(cm.exception))\n        self.assertIn(child, cm.exception.protected_objects)\n"], "sample_52": ["    def test_create_model(self):\n        \"\"\"\n        Tests the CreateModel operation.\n        \"\"\"\n        project_state = ProjectState()\n        operation = migrations.CreateModel(\n            name=\"TestModel\",\n            fields=[\n                (\"id\", models.AutoField(primary_key=True)),\n                (\"name\", models.CharField(max_length=255)),\n            ],\n            options={\"verbose_name\": \"Test Model\"},\n            bases=(models.Model,),\n            managers=[(\"objects\", models.Manager())],\n        )\n\n        # Test state forwards\n        operation.state_forwards(\"test_app\", project_state)\n        self.assertIn((\"test_app\", \"testmodel\"), project_state.models)\n        model_state = project_state.models[\"test_app\", \"testmodel\"]\n        self.assertEqual(model_state.name, \"TestModel\")\n        self.assertEqual(model_state.fields, [\n            (\"id\", models.AutoField(primary_key=True)),\n            (\"name\", models.CharField(max_length=255)),\n        ])\n        self.assertEqual(model_state.options[\"verbose_name\"], \"Test Model\")\n        self.assertEqual(model_state.managers, [(\"objects\", models.Manager())])\n\n        # Test database forwards\n        with connection.schema_editor() as editor:\n            operation.database_forwards(\"test_app\", editor, project_state, project_state)\n        self.assertTableExists(\"test_app_testmodel\")\n\n        # Test database backwards\n        with connection.schema_editor() as editor:\n            operation.database_backwards(\"test_app\", editor, project_state, project_state)\n        self.assertTableNotExists(\"test_app_testmodel\")\n\n        # Test deconstruction\n        name, args, kwargs = operation.deconstruct()\n        self.assertEqual(name, \"CreateModel\")\n        self.assertEqual(kwargs[\"name\"], \"TestModel\")\n        self.assertEqual(kwargs[\"fields\"], [\n            (\"id\", models.AutoField(primary_key=True)),\n            (\"name\", models.CharField(max_length=255)),\n        ])\n        self.assertEqual(kwargs[\"options\"], {\"verbose_name\": \"Test Model\"})\n        self.assertEqual(kwargs[\"bases\"], (models.Model,))\n        self.assertEqual(kwargs[\"managers\"], [(\"objects\", models.Manager())])\n"], "sample_69": ["def test_artist_set_alpha():\n    artist = martist.Artist()\n    \n    # Test valid alpha values\n    artist.set_alpha(0.5)\n    assert artist.get_alpha() == 0.5\n    \n    artist.set_alpha(1.0)\n    assert artist.get_alpha() == 1.0\n    \n    artist.set_alpha(0.0)\n    assert artist.get_alpha() == 0.0\n    \n    # Test invalid alpha values\n    with pytest.raises(ValueError):\n        artist.set_alpha(1.5)\n    \n    with pytest.raises(ValueError):\n        artist.set_alpha(-0.5)\n    \n    with pytest.raises(TypeError):\n        artist.set_alpha(\"invalid\")\n    \n    # Test setting alpha to None\n    artist.set_alpha(None)\n    assert artist.get_alpha() is None\n"], "sample_121": ["def test_af_rmul():\n    a = [1, 0, 2]\n    b = [0, 2, 1]\n    assert _af_rmul(a, b) == [1, 2, 0]\n    assert _af_rmul([2, 0, 1], [1, 2, 0]) == [0, 2, 1]\n"], "sample_58": ["    def test_settings_to_cmd_args_env_with_all_options(self):\n        settings_dict = {\n            \"HOST\": \"localhost\",\n            \"PORT\": 5432,\n            \"NAME\": \"test_db\",\n            \"USER\": \"test_user\",\n            \"PASSWORD\": \"test_password\",\n            \"OPTIONS\": {\n                \"passfile\": \"/path/to/passfile\",\n                \"service\": \"test_service\",\n                \"sslmode\": \"require\",\n                \"sslrootcert\": \"/path/to/root.crt\",\n                \"sslcert\": \"/path/to/client.crt\",\n                \"sslkey\": \"/path/to/client.key\",\n            },\n        }\n        parameters = [\"-c\", \"SELECT 1\"]\n        expected_args = [\n            \"psql\", \"-U\", \"test_user\", \"-h\", \"localhost\", \"-p\", \"5432\", \"-c\", \"SELECT 1\", \"test_db\"\n        ]\n        expected_env = {\n            \"PGPASSWORD\": \"test_password\",\n            \"PGSERVICE\": \"test_service\",\n            \"PGSSLMODE\": \"require\",\n            \"PGSSLROOTCERT\": \"/path/to/root.crt\",\n            \"PGSSLCERT\": \"/path/to/client.crt\",\n            \"PGSSLKEY\": \"/path/to/client.key\",\n            \"PGPASSFILE\": \"/path/to/passfile\",\n        }\n        args, env = self.settings_to_cmd_args_env(settings_dict, parameters)\n        self.assertEqual(args, expected_args)\n        self.assertEqual(env, expected_env)\n"], "sample_126": ["def test_comp():\n    assert comp(1, 1) == True\n    assert comp(1, 2) == False\n    assert comp(1.0, 1.0) == True\n    assert comp(1.0, 2.0) == False\n    assert comp(1.0, 1.0, 0.1) == True\n    assert comp(1.0, 1.1, 0.1) == True\n    assert comp(1.0, 1.2, 0.1) == False\n    assert comp(Float(1.0), Float(1.0)) == True\n    assert comp(Float(1.0), Float(2.0)) == False\n    assert comp(Float(1.0), Float(1.0), 0.1) == True\n    assert comp(Float(1.0), Float(1.1), 0.1) == True\n    assert comp(Float(1.0), Float(1.2), 0.1) == False\n    assert comp(Float(1.0), \"1.0\") == True\n    assert comp(Float(1.0), \"2.0\") == False\n    assert comp(Float(1.0), \"1.0\", '') == True\n    assert comp(Float(1.0), \"2.0\", '') == False\n    raises(ValueError, lambda: comp(\"1.0\", \"1.0\"))\n    raises(ValueError, lambda: comp(1.0, \"1.0\", 0.1))\n"], "sample_41": ["    def test_management_form_initialization(self):\n        form = ManagementForm()\n        self.assertIn(TOTAL_FORM_COUNT, form.fields)\n        self.assertIn(INITIAL_FORM_COUNT, form.fields)\n        self.assertIn(MIN_NUM_FORM_COUNT, form.fields)\n        self.assertIn(MAX_NUM_FORM_COUNT, form.fields)\n"], "sample_94": ["def test_source_init_with_string():\n    source_code = \"def foo():\\n    return 42\"\n    source = Source(source_code)\n    assert source.lines == [\"def foo():\", \"    return 42\"]\n"], "sample_65": ["    def test_join_with_hyphen(self):\n        output = self.engine.render_to_string(\"join02\", {\"a\": [\"apple\", \"banana\", \"cherry\"]})\n        self.assertEqual(output, \"apple - banana - cherry\")\n"], "sample_72": ["def test_figure_size():\n    fig = Figure(figsize=(8, 6))\n    assert fig.get_figwidth() == 8\n    assert fig.get_figheight() == 6\n"], "sample_122": ["def test_sparse_matrix_creation():\n    # Test creation with a range\n    sm = SparseMatrix(2, 2, range(4))\n    assert sm.shape == (2, 2)\n    assert sm[0, 0] == 0\n    assert sm[0, 1] == 1\n    assert sm[1, 0] == 2\n    assert sm[1, 1] == 3\n\n    # Test creation with a dictionary\n    sm = SparseMatrix(2, 2, {(1, 1): 2})\n    assert sm.shape == (2, 2)\n    assert sm[0, 0] == 0\n    assert sm[0, 1] == 0\n    assert sm[1, 0] == 0\n    assert sm[1, 1] == 2\n\n    # Test creation with a callable\n    sm = SparseMatrix(2, 2, lambda i, j: i + j)\n    assert sm.shape == (2, 2)\n    assert sm[0, 0] == 0\n    assert sm[0, 1] == 1\n    assert sm[1, 0] == 1\n    assert sm[1, 1] == 2\n\n    # Test creation with a sequence\n    sm = SparseMatrix(2, 2, [1, 2, 3, 4])\n    assert sm.shape == (2, 2)\n    assert sm[0, 0] == 1\n    assert sm[0, 1] == 2\n    assert sm[1, 0] == 3\n    assert sm[1, 1] == 4\n\n    # Test creation with invalid sequence length\n    raises(ValueError, lambda: SparseMatrix(2, 2, [1, 2, 3]))\n\n    # Test creation with another SparseMatrix\n    sm2 = SparseMatrix(sm)\n    assert sm2.shape == (2, 2)\n    assert sm2[0, 0] == 1\n    assert sm2[0, 1] == 2\n    assert sm2[1, 0] == 3\n    assert sm2[1, 1] == 4\n"], "sample_91": ["    def test_evaluate_skip_marks_unconditional_skip(self):\n        item = pytest.Function.from_parent(pytest.Module.from_parent(pytest.Session(), name=\"test_module\"), name=\"test_func\")\n        item.add_marker(pytest.mark.skip(reason=\"unconditional skip\"))\n        skip_result = evaluate_skip_marks(item)\n        assert skip_result is not None\n        assert skip_result.reason == \"unconditional skip\"\n"], "sample_115": ["def test_wrap_in_pandas_container_with_callable_columns():\n    pd = pytest.importorskip(\"pandas\")\n\n    data = np.array([[1, 2], [3, 4]])\n    columns_callable = lambda: [\"col1\", \"col2\"]\n\n    result = _wrap_in_pandas_container(data, columns=columns_callable)\n    expected = pd.DataFrame(data, columns=[\"col1\", \"col2\"])\n\n    assert result.equals(expected)\n\n"], "sample_15": ["    def test_valid_language_code(self):\n        errors = check_setting_language_code(None)\n        self.assertEqual(errors, [])\n"], "sample_12": ["    def test_generate_renamed_models(self):\n        \"\"\"\n        Test the generation of RenameModel operations.\n        \"\"\"\n        before = [self.author_empty]\n        after = [self.author_renamed_with_book]\n        questioner = mock.Mock(spec=MigrationQuestioner)\n        questioner.ask_rename_model.return_value = True\n        changes = self.get_changes(before, after, questioner)\n        self.assertNumberMigrations(changes, \"testapp\", 1)\n        self.assertOperationTypes(changes, \"testapp\", 0, [\"RenameModel\"])\n        self.assertOperationAttributes(changes, \"testapp\", 0, 0, old_name=\"Author\", new_name=\"Writer\")\n"], "sample_100": ["def test_one_hot_encoder_handle_unknown():\n    # Test the handle_unknown parameter of OneHotEncoder\n    X = np.array([['a', 1], ['b', 2], ['c', 3]], dtype=object)\n    enc = OneHotEncoder(handle_unknown='ignore')\n    enc.fit(X)\n    X_trans = enc.transform([['a', 1], ['b', 4]])\n    expected = np.array([[1., 0., 0., 1., 0., 0.],\n                         [0., 1., 0., 0., 0., 0.]])\n    assert_array_equal(toarray(X_trans), expected)\n\n    enc = OneHotEncoder(handle_unknown='error')\n    enc.fit(X)\n    with pytest.raises(ValueError, match=\"Found unknown categories\"):\n        enc.transform([['a', 1], ['b', 4]])\n"], "sample_81": ["    def test_fixme_detection(self):\n        self.checker.process_tokens(_tokenize_str(\"# FIXME: this needs to be fixed\\n\"))\n        self.assertAddsMessages(\n            MessageTest(\n                msg_id=\"fixme\",\n                line=1,\n                args=\"FIXME: this needs to be fixed\",\n                col_offset=1,\n            )\n        )\n"], "sample_4": ["    def test_http_response_init(self):\n        response = HttpResponse(content=b\"Hello, world!\", content_type=\"text/plain\", status=200)\n        self.assertEqual(response.content, b\"Hello, world!\")\n        self.assertEqual(response['Content-Type'], \"text/plain\")\n        self.assertEqual(response.status_code, 200)\n"], "sample_1": ["def test__line_type():\n    assert _line_type(\"READ SERR 3\") == 'command'\n    assert _line_type(\" \\\\n    !some gibberish\") == 'comment'\n    assert _line_type(\"   \") == 'comment'\n    assert _line_type(\" 21345.45\") == 'data,1'\n    assert _line_type(\" 21345.45 1.53e-3 1e-3 .04 NO nan\") == 'data,6'\n    assert _line_type(\" 21345.45,1.53e-3,1e-3,.04,NO,nan\", delimiter=',') == 'data,6'\n    assert _line_type(\" 21345.45 ! a comment to disturb\") == 'data,1'\n    assert _line_type(\"NO NO NO NO NO\") == 'new'\n    assert _line_type(\"NO,NO,NO,NO,NO\", delimiter=',') == 'new'\n    with pytest.raises(ValueError, match=\"Unrecognized QDP line\"):\n        _line_type(\"N O N NOON OON O\")\n    with pytest.raises(ValueError, match=\"Unrecognized QDP line\"):\n        _line_type(\" some non-comment gibberish\")\n"], "sample_102": ["def test_isolation_forest_fit_predict():\n    # Test the fit and predict methods of IsolationForest\n    X = iris.data\n    clf = IsolationForest(random_state=rng)\n    clf.fit(X)\n    y_pred = clf.predict(X)\n    \n    # Check that the prediction is either 1 or -1\n    assert set(y_pred) <= {1, -1}\n\n    # Check that the number of inliers and outliers is reasonable\n    n_outliers = np.sum(y_pred == -1)\n    n_inliers = np.sum(y_pred == 1)\n    assert n_outliers > 0\n    assert n_inliers > 0\n\n    # Check that the contamination parameter affects the number of outliers\n    clf_high_contamination = IsolationForest(contamination=0.4, random_state=rng)\n    clf_high_contamination.fit(X)\n    y_pred_high_contamination = clf_high_contamination.predict(X)\n    n_outliers_high_contamination = np.sum(y_pred_high_contamination == -1)\n    assert n_outliers_high_contamination > n_outliers\n\n    clf_low_contamination = IsolationForest(contamination=0.01, random_state=rng)\n    clf_low_contamination.fit(X)\n    y_pred_low_contamination = clf_low_contamination.predict(X)\n    n_outliers_low_contamination = np.sum(y_pred_low_contamination == -1)\n    assert n_outliers_low_contamination < n_outliers\n"], "sample_139": ["def test_re_im():\n    x, y = symbols('x y')\n    assert re(2*E) == 2*E\n    assert re(2*I + 17) == 17\n    assert re(2*I) == 0\n    assert re(im(x) + x*I + 2) == 2\n    assert re(x + I*y) == x\n    assert re(2 + 3*I).as_real_imag() == (2, 0)\n    assert re(nan) == nan\n    assert re(oo) == oo\n    assert re(-oo) == -oo\n    assert re(zoo) == nan\n    assert re(2 + 3*I).diff(x) == 0\n    assert re(2 + 3*I).diff(y) == 0\n    assert re(x + I*y).diff(x) == 1\n    assert re(x + I*y).diff(y) == 0\n    assert re(x + I*y).rewrite(im) == x - I*im(x + I*y)\n    assert re(x + I*y).is_real is True\n    assert re(x + I*y).is_zero is None\n    assert re(x + I*y).is_finite is None\n    assert re(x + I*y).is_complex is True\n\n    assert im(2*E) == 0\n    assert im(2*I + 17) == 2\n    assert im(x*I) == re(x)\n    assert im(re(x) + y) == im(y)\n    assert im(x + I*y) == y\n    assert im(2 + 3*I).as_real_imag() == (3, 0)\n    assert im(nan) == nan\n    assert im(oo) == 0\n    assert im(-oo) == 0\n    assert im(zoo) == nan\n    assert im(2 + 3*I).diff(x) == 0\n    assert im(2 + 3*I).diff(y) == 0\n    assert im(x + I*y).diff(x) == 0\n    assert im(x + I*y).diff(y) == 1\n    assert im(x + I*y).rewrite(re) == -I*(x - re(x + I*y))\n    assert im(x + I*y).is_real is"], "sample_125": ["def test_comp():\n    assert comp(1, 1) == True\n    assert comp(1, 2) == False\n    assert comp(1.0, 1.0) == True\n    assert comp(1.0, 1.0000000001) == True\n    assert comp(1.0, 1.0000000001, tol=1e-10) == False\n    assert comp(1.0, 1.0000000001, tol=1e-9) == True\n    assert comp(1.0, \"1.0\") == True\n    assert comp(1.0, \"1.0000000001\") == False\n    assert comp(1.0, \"1.0000000001\", tol='') == False\n    assert comp(1.0, \"1.0000000001\", tol=None) == False\n    raises(ValueError, lambda: comp(1, \"1.0\"))\n    raises(ValueError, lambda: comp(1, 1.0, tol=''))\n"], "sample_131": ["def test_basic_operations():\n    assert mcode(x + y) == 'x + y'\n    assert mcode(x * y) == 'x*y'\n    assert mcode(x**2) == 'x^2'\n    assert mcode(x - y) == 'x - y'\n    assert mcode(x / y) == 'x/y'\n"], "sample_29": ["    def setUp(self):\n        self.raw_query = RawQuery(\"SELECT * FROM my_table WHERE id = %s\", using='default', params=(1,))\n"], "sample_32": ["    def test_jsonfield_encoder_decoder(self):\n        class CustomEncoder(json.JSONEncoder):\n                if isinstance(obj, uuid.UUID):\n                    return str(obj)\n                return super().default(obj)\n\n        class CustomDecoder(json.JSONDecoder):\n                super().__init__(object_hook=self.object_hook, *args, **kwargs)\n\n                if 'uuid' in obj:\n                    obj['uuid'] = uuid.UUID(obj['uuid'])\n                return obj\n\n        field = JSONField(encoder=CustomEncoder, decoder=CustomDecoder)\n        value = {'uuid': uuid.uuid4()}\n        prepped_value = field.get_prep_value(value)\n        self.assertEqual(prepped_value, json.dumps(value, cls=CustomEncoder))\n        from_db_value = field.from_db_value(prepped_value, None, None)\n        self.assertEqual(from_db_value, value)\n"], "sample_62": ["    def setUp(self):\n        self.temp_dir = tempfile.mkdtemp()\n        self.cache = FileBasedCache(self.temp_dir, {'TIMEOUT': 30})\n"], "sample_33": ["    def test_connect_with_dispatch_uid(self):\n            return \"received\"\n\n        signal = Signal()\n        dispatch_uid = \"unique_id\"\n        signal.connect(receiver_func, dispatch_uid=dispatch_uid)\n        self.assertTrue(signal.has_listeners())\n        self.assertEqual(len(signal.receivers), 1)\n\n        # Connect another receiver with the same dispatch_uid, should not add a new one\n        signal.connect(lambda signal, sender, **kwargs: \"another\", dispatch_uid=dispatch_uid)\n        self.assertEqual(len(signal.receivers), 1)\n\n        # Disconnect the receiver\n        signal.disconnect(dispatch_uid=dispatch_uid)\n        self.assertFalse(signal.has_listeners())\n        self.assertEqual(signal.receivers, [])\n"], "sample_93": ["def test_temp_path_factory_mktemp(tmp_path_factory: TempPathFactory):\n    temp_dir = tmp_path_factory.mktemp(\"testdir\")\n    assert temp_dir.exists()\n    assert temp_dir.is_dir()\n    assert \"testdir\" in str(temp_dir)\n"], "sample_42": ["    def test_base_serializer(self):\n        with self.assertRaises(NotImplementedError):\n            BaseSerializer(1).serialize()\n"], "sample_142": ["def test_is_palindromic():\n    assert is_palindromic([1, 0, 1]) is True\n    assert is_palindromic('abcbb') is False\n    assert is_palindromic('abcbb', 1) is False\n    assert is_palindromic('abcbb', 1, -1) is True\n    assert is_palindromic('abcbb', -4, -1) is True\n    assert is_palindromic('a') is True\n    assert is_palindromic('') is True\n    assert is_palindromic([1, 2, 3, 2, 1]) is True\n    assert is_palindromic([1, 2, 3, 4, 5]) is False\n"], "sample_120": ["def test_matrix_symbol_properties():\n    # Test MatrixSymbol properties\n    F = MatrixSymbol('F', 2, 3)\n    assert F.shape == (2, 3)\n    assert F.name == 'F'\n    assert F.is_commutative == False\n    assert F.free_symbols == {F}\n\n    # Test substitution in shape\n    G = F._eval_subs(2, 4)\n    assert G.shape == (4, 3)\n    assert G.name == 'F'\n\n    # Test entry method\n    assert isinstance(F._entry(0, 1), MatrixElement)\n    assert F._entry(0, 1).parent == F\n    assert F._entry(0, 1).i == 0\n    assert F._entry(0, 1).j == 1\n\n    # Test doit method\n    assert F.doit() == F\n    assert F.doit(deep=False) == F\n"], "sample_14": ["    def test_serialize_datetime(self):\n        value = datetime.datetime(2023, 10, 1, 12, 0, 0, tzinfo=utc)\n        serializer = serializer_factory(value)\n        serialized_value, imports = serializer.serialize()\n        self.assertEqual(serialized_value, \"datetime.datetime(2023, 10, 1, 12, 0, tzinfo=utc)\")\n        self.assertEqual(imports, {\"import datetime\", \"from django.utils.timezone import utc\"})\n"], "sample_157": ["def test_tensor_product_matrices():\n    tp = TensorProduct(mat1, mat2)\n    expected_result = Matrix([\n        [2*I, 3, 4*I, 2, 4*I, 6, 8*I, 4],\n        [4*I, 2, 6*I, 3, 8*I, 4, 12*I, 6],\n        [2*I + 2, 3 + 3*I, 4*I + 4, 2 + 2*I, 4*I + 4, 6 + 6*I, 8*I + 8, 4 + 4*I],\n        [4*I + 4, 2 + 2*I, 6*I + 6, 3 + 3*I, 8*I + 8, 4 + 4*I, 12*I + 12, 6 + 6*I],\n        [2*I, 3, 4*I, 2, 6*I, 9, 12*I, 6],\n        [4*I, 2, 6*I, 3, 12*I, 6, 18*I, 9],\n        [2*I + 2, 3 + 3*I, 4*I + 4, 2 + 2*I, 6*I + 6, 9 + 9*I, 12*I + 12, 6 + 6*I],\n        [4*I + 4, 2 + 2*I, 6*I + 6, 3 + 3*I, 12*I + 12, 6 + 6*I, 18*I + 18, 9 + 9*I]\n    ])\n    assert tp == expected_result\n"], "sample_110": ["def test_affinity_propagation_convergence():\n    # Test that AffinityPropagation converges and returns correct number of clusters\n    af = AffinityPropagation(preference=-50).fit(X)\n    labels = af.labels_\n    cluster_centers_indices = af.cluster_centers_indices_\n    n_clusters_ = len(cluster_centers_indices)\n\n    assert n_clusters_ == n_clusters\n    assert len(np.unique(labels)) == n_clusters\n    assert len(cluster_centers_indices) == n_clusters\n    assert af.n_iter_ <= af.max_iter\n"], "sample_136": ["def test_blockmatrix_shape():\n    X = MatrixSymbol('X', 2, 3)\n    Y = MatrixSymbol('Y', 3, 4)\n    Z = MatrixSymbol('Z', 4, 5)\n    B = BlockMatrix([[X, Y], [ZeroMatrix(3, 2), Z]])\n    assert B.shape == (5, 9)\n"], "sample_80": ["    def test_pretty_print(self):\n        assert formatting.pretty_print(\"test\", 10) == \"test      \"\n        assert formatting.pretty_print(\"test\", 3) == \"tes\"\n        assert formatting.pretty_print(\"test\", 4) == \"test\"\n        assert formatting.pretty_print(\"test\", 5) == \"test \"\n        assert formatting.pretty_print(\"\", 5) == \"     \"\n        assert formatting.pretty_print(\"test\", 0) == \"\"\n"], "sample_99": ["def test_check_weights():\n    \"\"\"Test the _check_weights function for various inputs.\"\"\"\n    # Valid inputs\n    assert_equal(_check_weights(None), None)\n    assert_equal(_check_weights('uniform'), 'uniform')\n    assert_equal(_check_weights('distance'), 'distance')\n    assert_equal(_check_weights(_weight_func), _weight_func)\n\n    # Invalid inputs\n    assert_raises(ValueError, _check_weights, 'invalid')\n    assert_raises(ValueError, _check_weights, 123)\n    assert_raises(ValueError, _check_weights, [1, 2, 3])\n"], "sample_6": ["    def test_ascii_username_validator_valid(self):\n        validator = validators.ASCIIUsernameValidator()\n        valid_usernames = ['user123', 'user.name', 'user_name', 'user-name', 'user+name']\n        for username in valid_usernames:\n            with self.subTest(username=username):\n                try:\n                    validator(username)\n                except ValidationError:\n                    self.fail(f\"ASCIIUsernameValidator raised ValidationError unexpectedly for username: {username}\")\n"], "sample_66": ["    def test_autocomplete_fields_not_list_or_tuple(self):\n        class BandAdmin(ModelAdmin):\n            autocomplete_fields = \"not-a-list-or-tuple\"\n\n        self.assertIsInvalid(\n            BandAdmin,\n            Band,\n            \"The value of 'autocomplete_fields' must be a list or tuple.\",\n            id=\"admin.E036\",\n        )\n"], "sample_25": ["    def test_generate_renamed_models(self):\n        \"\"\"\n        Test that renamed models are detected and the appropriate RenameModel\n        operation is generated.\n        \"\"\"\n        before_states = [self.author_empty]\n        after_states = [self.author_renamed_with_book]\n        questioner = mock.Mock(spec=MigrationQuestioner)\n        questioner.ask_rename_model.return_value = True\n\n        changes = self.get_changes(before_states, after_states, questioner)\n\n        self.assertNumberMigrations(changes, \"testapp\", 1)\n        self.assertOperationTypes(changes, \"testapp\", 0, [\"RenameModel\"])\n        self.assertOperationAttributes(changes, \"testapp\", 0, 0, old_name=\"Author\", new_name=\"Writer\")\n"], "sample_63": ["    def test_get_context_no_password(self):\n        widget = ReadOnlyPasswordHashWidget()\n        context = widget.get_context('password', None, {})\n        self.assertIn('summary', context)\n        self.assertEqual(context['summary'][0]['label'], gettext(\"No password set.\"))\n"], "sample_96": ["def test_ridge_regression_solvers():\n    # Generate a simple regression problem\n    X, y = make_regression(n_samples=100, n_features=20, noise=0.1, random_state=42)\n    alphas = [0.1, 1.0, 10.0]\n    solvers = ['auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga']\n\n    for solver in solvers:\n        ridge = Ridge(alpha=1.0, solver=solver)\n        ridge.fit(X, y)\n        coef = ridge.coef_\n\n        # Check that the coefficients are not all zeros\n        assert_true(np.any(coef != 0), msg=f\"Solver {solver} failed to produce non-zero coefficients\")\n\n        # Check that the solver converges to a solution close to the true coefficients\n        y_pred = ridge.predict(X)\n        mse = mean_squared_error(y, y_pred)\n        assert_greater(1.0, mse, msg=f\"Solver {solver} produced a high mean squared error: {mse}\")\n\n    # Check that an invalid solver raises a ValueError\n    invalid_solver = 'invalid_solver'\n    ridge = Ridge(alpha=1.0, solver=invalid_solver)\n    assert_raises(ValueError, ridge.fit, X, y)\n"], "sample_36": ["    def test_q_and_combination(self):\n        q1 = Q(a=1)\n        q2 = Q(b=2)\n        combined_q = q1 & q2\n        self.assertEqual(combined_q.connector, Q.AND)\n        self.assertIn(('a', 1), combined_q.children)\n        self.assertIn(('b', 2), combined_q.children)\n"], "sample_78": ["def test_find_best_app():\n    class MockFlask:\n        pass\n\n    module = types.ModuleType(\"mock_module\")\n    module.app = MockFlask()\n    assert find_best_app(module) == module.app\n\n    module = types.ModuleType(\"mock_module\")\n    module.application = MockFlask()\n    assert find_best_app(module) == module.application\n\n    module = types.ModuleType(\"mock_module\")\n    module.app = MockFlask()\n    module.application = MockFlask()\n    with pytest.raises(NoAppException):\n        find_best_app(module)\n\n    module = types.ModuleType(\"mock_module\")\n    module.create_app = lambda: MockFlask()\n    assert find_best_app(module) == module.create_app()\n\n    module = types.ModuleType(\"mock_module\")\n    module.make_app = lambda: MockFlask()\n    assert find_best_app(module) == module.make_app()\n\n    module = types.ModuleType(\"mock_module\")\n    module.create_app = lambda: None\n    with pytest.raises(NoAppException):\n        find_best_app(module)\n\n    module = types.ModuleType(\"mock_module\")\n    with pytest.raises(NoAppException):\n        find_best_app(module)\n"], "sample_2": ["    def setup(self):\n        self.header = fits.Header.fromstring(\"\"\"\n        WCSAXES =                    2 / Number of coordinate axes\n        CRPIX1  =                1024.0 / Pixel coordinate of reference point\n        CRPIX2  =                1024.0 / Pixel coordinate of reference point\n        CDELT1  =   -2.7777777777778E-05 / [deg] Coordinate increment at reference point\n        CDELT2  =    2.7777777777778E-05 / [deg] Coordinate increment at reference point\n        CUNIT1  = 'deg'                / Units of coordinate increment and value\n        CUNIT2  = 'deg'                / Units of coordinate increment and value\n        CTYPE1  = 'RA---TAN'           / Right ascension, gnomonic projection\n        CTYPE2  = 'DEC--TAN'           / Declination, gnomonic projection\n        CRVAL1  =                  0.0 / [deg] Coordinate value at reference point\n        CRVAL2  =                  0.0 / [deg] Coordinate value at reference point\n        LONPOLE =                180.0 / [deg] Native longitude of celestial pole\n        LATPOLE =                  0.0 / [deg] Native latitude of celestial pole\n        \"\"\", sep='\\n')\n"], "sample_71": ["def test_use_style_from_dict():\n    \"\"\"Test using a style directly from a dictionary.\"\"\"\n    custom_style = {'axes.facecolor': 'red', 'axes.edgecolor': 'blue'}\n    original_rc = mpl.rcParams.copy()\n    try:\n        style.use(custom_style)\n        assert mpl.rcParams['axes.facecolor'] == 'red'\n        assert mpl.rcParams['axes.edgecolor'] == 'blue'\n    finally:\n        mpl.rcParams.update(original_rc)\n"], "sample_26": ["    def test_create_test_db(self, mock_call_command):\n        test_connection = get_connection_copy()\n        creation = BaseDatabaseCreation(test_connection)\n\n        with mock.patch.object(creation, '_get_test_db_name', return_value='test_db'):\n            with mock.patch.object(creation, '_create_test_db') as mock_create_test_db:\n                with mock.patch.object(creation, 'log') as mock_log:\n                    test_db_name = creation.create_test_db(verbosity=2, autoclobber=True, serialize=False, keepdb=False)\n\n                    self.assertEqual(test_db_name, 'test_db')\n                    mock_create_test_db.assert_called_once_with(2, True, False)\n                    mock_log.assert_any_call(\"Creating test database for alias 'default' ('test_db')...\")\n\n                    mock_call_command.assert_any_call(\n                        'migrate',\n                        verbosity=1,\n                        interactive=False,\n                        database=test_connection.alias,\n                        run_syncdb=True,\n                    )\n                    mock_call_command.assert_any_call('createcachetable', database=test_connection.alias)\n"], "sample_23": ["    def setUpTestData(cls):\n        cls.number1 = Number.objects.create(num=1, other_num=9)\n        cls.number2 = Number.objects.create(num=2, other_num=8)\n"], "sample_117": ["def test_restify():\n    assert restify(None) == ':obj:`None`'\n    assert restify(NoneType) == ':obj:`None`'\n    assert restify(Ellipsis) == '...'\n    assert restify(Struct) == ':class:`struct.Struct`'\n    assert restify(MyInt) == ':class:`MyInt`'\n    assert restify(MyClass1) == ':class:`MyClass1`'\n    assert restify(MyClass2) == ':class:`<MyClass2>`'\n    assert restify(Optional[int]) == ':obj:`Optional`\\\\ [:class:`int`]'\n    assert restify(Union[int, str]) == ':obj:`Union`\\\\ [:class:`int`, :class:`str`]'\n    assert restify(Callable[[int, str], None]) == ':class:`Callable`\\\\ [[int, str], :obj:`None`]'\n    assert restify(Tuple[int, str]) == ':class:`Tuple`\\\\ [:class:`int`, :class:`str`]'\n    assert restify(MyList[int]) == ':class:`MyList`\\\\ [:class:`int`]'\n    assert restify(BrokenType) == ':obj:`BrokenType.int`'\n"], "sample_127": ["def test_latex_print_ComplexRegion():\n    from sympy.sets import ComplexRegion, Interval\n    from sympy.abc import x, y\n\n    # Define a complex region\n    region = ComplexRegion(Interval(0, 1) * Interval(0, 2))\n\n    # Test the LaTeX output\n    assert latex(region) == r\"\\left\\{ x + y i \\; |\\; x \\in \\left[0, 1\\right], y \\in \\left[0, 2\\right] \\right\\}\"\n"], "sample_87": ["    def test_pytest_ignore_collect(self):\n        config = pytest.Config.fromdictargs({}, [])\n        path = py.path.local(\"somepath\")\n        path.dirpath().ensure_dir()\n        path.ensure(file=True)\n        config._getconftest_pathlist = lambda *args, **kwargs: [path]\n        config.getoption = lambda option: None\n        assert pytest_ignore_collect(path, config) is True\n"], "sample_153": ["def test_pretty_printer_imaginary_unit():\n    from sympy import I\n    from sympy.printing.pretty.pretty import PrettyPrinter\n\n    # Test for imaginary unit 'i'\n    pp_i = PrettyPrinter({'imaginary_unit': 'i'})\n    assert pp_i.doprint(I) == 'i'\n\n    # Test for imaginary unit 'j'\n    pp_j = PrettyPrinter({'imaginary_unit': 'j'})\n    assert pp_j.doprint(I) == 'j'\n\n    # Test for invalid imaginary unit type\n    try:\n        PrettyPrinter({'imaginary_unit': 1})\n    except TypeError as e:\n        assert str(e) == \"'imaginary_unit' must a string, not 1\"\n\n    # Test for invalid imaginary unit value\n    try:\n        PrettyPrinter({'imaginary_unit': 'k'})\n    except ValueError as e:\n        assert str(e) == \"'imaginary_unit' must be either 'i' or 'j', not 'k'\"\n"], "sample_82": ["def test_unique_value_groups():\n    array = np.array([1, 2, 2, 3, 1, 4, 4, 4])\n    values, groups = unique_value_groups(array)\n    expected_values = np.array([1, 2, 3, 4])\n    expected_groups = [[0, 4], [1, 2], [3], [5, 6, 7]]\n    \n    assert np.array_equal(values, expected_values)\n    assert groups == expected_groups\n"], "sample_0": ["    def test_media_initialization(self):\n        media = Media(css={'all': ['style.css']}, js=['script.js'])\n        self.assertEqual(media._css, {'all': ['style.css']})\n        self.assertEqual(media._js, ['script.js'])\n"], "sample_70": ["def test_legend_initialization():\n    fig, ax = plt.subplots()\n    line, = ax.plot([1, 2, 3], label='Test Line')\n    scatter = ax.scatter([1, 2, 3], [3, 2, 1], label='Test Scatter')\n    legend = mlegend.Legend(ax, [line, scatter], ['Line', 'Scatter'], loc='upper right')\n    \n    assert legend._loc == 1  # 'upper right' corresponds to 1\n    assert legend.numpoints == mpl.rcParams['legend.numpoints']\n    assert legend.markerscale == mpl.rcParams['legend.markerscale']\n    assert legend.scatterpoints == mpl.rcParams['legend.scatterpoints']\n    assert legend.borderpad == mpl.rcParams['legend.borderpad']\n    assert legend.labelspacing == mpl.rcParams['legend.labelspacing']\n    assert legend.handlelength == mpl.rcParams['legend.handlelength']\n    assert legend.handleheight == mpl.rcParams['legend.handleheight']\n    assert legend.handletextpad == mpl.rcParams['legend.handletextpad']\n    assert legend.borderaxespad == mpl.rcParams['legend.borderaxespad']\n    assert legend.columnspacing == mpl.rcParams['legend.columnspacing']\n    assert legend.shadow == mpl.rcParams['legend.shadow']\n    assert legend._ncols == 1\n    assert legend._alignment == 'center'\n    assert legend.get_frame_on() == mpl.rcParams['legend.frameon']\n    assert legend.get_title().get_text() == ''\n    assert legend.get_title().get_fontproperties().get_size() == mpl.rcParams['legend.title_fontsize']\n    assert legend.get_draggable() is False\n"], "sample_56": ["compilation error"], "sample_18": ["    def test_resolve_relation_recursive(self):\n        class TestModel(models.Model):\n            pass\n\n        relation = resolve_relation(TestModel, 'self')\n        self.assertEqual(relation, TestModel)\n"], "sample_75": ["def test_grid_initialization():\n    fig = plt.figure()\n    grid = Grid(fig, 111, (2, 2), ngrids=4, direction=\"row\", axes_pad=0.05, share_all=True, label_mode=\"all\")\n\n    assert grid.get_geometry() == (2, 2)\n    assert len(grid) == 4\n    assert grid.get_axes_pad() == (0.05, 0.05)\n    assert grid.get_aspect() is False\n\n    for ax in grid:\n        assert isinstance(ax, Axes)\n        assert ax.get_figure() is fig\n\n    grid.set_axes_pad((0.1, 0.1))\n    assert grid.get_axes_pad() == (0.1, 0.1)\n\n    grid.set_aspect(True)\n    assert grid.get_aspect() is True\n\n    grid.set_label_mode(\"1\")\n    for ax in grid:\n        assert ax.xaxis.get_visible() is True\n        assert ax.yaxis.get_visible() is True\n"], "sample_114": ["def test_unique_labels():\n    # Test unique_labels with various input types\n    assert_array_equal(unique_labels([3, 5, 5, 5, 7, 7]), np.array([3, 5, 7]))\n    assert_array_equal(unique_labels([1, 2, 3, 4], [2, 2, 3, 4]), np.array([1, 2, 3, 4]))\n    assert_array_equal(unique_labels([1, 2, 10], [5, 11]), np.array([1, 2, 5, 10, 11]))\n\n    # Test mix of multilabel and multiclass targets\n    with pytest.raises(ValueError, match=\"Mix type of y not allowed\"):\n        unique_labels([1, 2, 3], [[1, 0], [0, 1]])\n\n    # Test mix of label indicator matrix and anything else\n    with pytest.raises(ValueError, match=\"Mix type of y not allowed\"):\n        unique_labels([[1, 0], [0, 1]], [1, 2, 3])\n\n    # Test mix of label indicator matrices of different sizes\n    with pytest.raises(ValueError, match=\"Multi-label binary indicator input with different numbers of labels\"):\n        unique_labels([[1, 0], [0, 1]], [[1, 0, 0], [0, 1, 1]])\n\n    # Test mix of string and integer labels\n    with pytest.raises(ValueError, match=\"Mix of label input types\"):\n        unique_labels([1, 2, 3], [\"a\", \"b\", \"c\"])\n\n    # Test empty input\n    with pytest.raises(ValueError, match=\"No argument has been passed\"):\n        unique_labels()\n"], "sample_112": ["def test_isotonic_regression_basic():\n    # Test basic functionality of isotonic_regression function\n    y = np.array([3, 1, 2, 4])\n    expected_result = np.array([2, 2, 2, 4])\n    result = isotonic_regression(y)\n    assert_array_almost_equal(result, expected_result)\n"], "sample_138": ["def test_BlockMatrix_creation():\n    X = MatrixSymbol('X', n, n)\n    Y = MatrixSymbol('Y', m, m)\n    Z = MatrixSymbol('Z', n, m)\n    B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])\n    assert B.shape == (n + m, n + m)\n    assert B.blockshape == (2, 2)\n    assert B.rowblocksizes == [n, m]\n    assert B.colblocksizes == [n, m]\n    assert B.blocks[0, 0] == X\n    assert B.blocks[0, 1] == Z\n    assert B.blocks[1, 0] == ZeroMatrix(m, n)\n    assert B.blocks[1, 1] == Y\n"], "sample_16": ["    def test_lookup_needs_distinct_with_m2m_field(self):\n        opts = Article._meta\n        lookup_path = 'authors__name'\n        self.assertTrue(lookup_needs_distinct(opts, lookup_path))\n"], "sample_89": ["def test_splitnode(nodeid, expected_parts):\n    assert nodes._splitnode(nodeid) == expected_parts\n"], "sample_13": ["    def test_urlquote(self):\n        self.assertEqual(urlquote('http://example.com/test?name=John Doe'), 'http%3A//example.com/test%3Fname%3DJohn%20Doe')\n        self.assertEqual(urlquote('http://example.com/test?name=John Doe', safe=':/'), 'http://example.com/test%3Fname%3DJohn%20Doe')\n"], "sample_50": ["    def test_message_encoder_decoder(self):\n        \"\"\"\n        Test that MessageEncoder and MessageDecoder correctly encode and decode\n        Message instances.\n        \"\"\"\n        message = Message(constants.INFO, \"Test message\", extra_tags=\"extra\")\n        encoded_message = json.dumps(message, cls=MessageEncoder)\n        decoded_message = json.loads(encoded_message, cls=MessageDecoder)\n        \n        self.assertEqual(message.level, decoded_message.level)\n        self.assertEqual(message.message, decoded_message.message)\n        self.assertEqual(message.extra_tags, decoded_message.extra_tags)\n        self.assertIsInstance(decoded_message, Message)\n"], "sample_92": ["    def test_evaluate_skip_marks_unconditional(self):\n        \"\"\"Test evaluate_skip_marks with an unconditional skip.\"\"\"\n        item = pytest.Function.from_parent(pytest.Module.from_parent(pytest.Session(), name=\"test_module\"), name=\"test_func\")\n        item.add_marker(pytest.mark.skip(reason=\"unconditional skip\"))\n        skip_result = evaluate_skip_marks(item)\n        assert skip_result is not None\n        assert skip_result.reason == \"unconditional skip\"\n"], "sample_135": ["def test_basic_eq():\n    x, y = symbols('x y')\n    assert Basic(x) == Basic(x)\n    assert Basic(x) != Basic(y)\n    assert Basic(x, y) == Basic(x, y)\n    assert Basic(x, y) != Basic(y, x)\n    assert Basic(x, y) != Basic(x)\n    assert Basic(x) != Basic(x, y)\n    assert Basic(x, y) != Basic(x, y, x)\n    assert Basic(x, y, x) == Basic(x, y, x)\n    assert Basic(x, y, x) != Basic(x, y, y)\n"], "sample_46": ["    def setUp(self):\n        self.reference = Table('table', lambda table: table.upper())\n"], "sample_159": ["def test_prefix_creation():\n    # Test creation of SI prefixes\n    assert kilo.name == 'kilo'\n    assert kilo.abbrev == 'k'\n    assert kilo.scale_factor == 10**3\n    assert kilo.base == 10\n\n    # Test creation of binary prefixes\n    assert kibi.name == 'kibi'\n    assert kibi.abbrev == 'Y'\n    assert kibi.scale_factor == 2**10\n    assert kibi.base == 2\n"], "sample_24": ["    def test_validation_error_with_message_string(self):\n        error = ValidationError(\"This is an error message\")\n        self.assertEqual(str(error), \"['This is an error message']\")\n        self.assertEqual(error.message, \"This is an error message\")\n        self.assertIsNone(error.code)\n        self.assertIsNone(error.params)\n        self.assertEqual(error.error_list, [error])\n"], "sample_147": ["def test_coeff_isneg():\n    from sympy.core.function import _coeff_isneg\n    from sympy import S, Symbol, oo, pi, sqrt, MatrixSymbol\n\n    assert _coeff_isneg(-3 * pi) is True\n    assert _coeff_isneg(S(3)) is False\n    assert _coeff_isneg(-oo) is True\n    assert _coeff_isneg(Symbol('n', negative=True)) is False\n\n    A = MatrixSymbol(\"A\", 3, 3)\n    assert _coeff_isneg(-sqrt(2) * A) is True\n    assert _coeff_isneg(sqrt(2) * A) is False\n"], "sample_57": ["    def test_management_form_clean(self):\n        data = {\n            TOTAL_FORM_COUNT: '3',\n            INITIAL_FORM_COUNT: '1',\n            MIN_NUM_FORM_COUNT: '0',\n            MAX_NUM_FORM_COUNT: '5',\n        }\n        form = ManagementForm(data)\n        self.assertTrue(form.is_valid())\n        cleaned_data = form.clean()\n        self.assertEqual(cleaned_data[TOTAL_FORM_COUNT], 3)\n        self.assertEqual(cleaned_data[INITIAL_FORM_COUNT], 1)\n        self.assertEqual(cleaned_data[MIN_NUM_FORM_COUNT], 0)\n        self.assertEqual(cleaned_data[MAX_NUM_FORM_COUNT], 5)\n"], "sample_103": ["def test_mutual_info_regression():\n    rng = check_random_state(0)\n    X = rng.rand(100, 5)\n    y = X[:, 0] + 0.5 * rng.rand(100)\n    \n    mi = mutual_info_regression(X, y)\n    assert_equal(mi.shape[0], X.shape[1])\n    assert_greater(mi[0], 0)\n    assert_array_equal(mi[1:], 0)\n"], "sample_101": ["def test_pipeline_fit_transform():\n    # Test fit_transform method of Pipeline\n    X = np.array([[1, 2], [3, 4], [5, 6]])\n    y = np.array([1, 2, 3])\n    \n    mult = Mult(mult=2)\n    pca = PCA(n_components=1)\n    pipeline = Pipeline([('mult', mult), ('pca', pca)])\n    \n    Xt = pipeline.fit_transform(X, y)\n    \n    # Check that the pipeline fit_transform works correctly\n    assert Xt.shape == (3, 1)\n    assert_array_almost_equal(Xt, pca.fit_transform(mult.transform(X)))\n    \n    # Check that fit_transform parameters are passed correctly\n    transf = TransfFitParams()\n    pipeline = Pipeline([('transf', transf), ('mult', mult)])\n    pipeline.fit_transform(X, y, transf__param=42)\n    assert 'param' in transf.fit_params\n    assert transf.fit_params['param'] == 42\n"], "sample_108": ["def test_svc_linear_kernel():\n    # Test SVC with linear kernel\n    clf = svm.SVC(kernel='linear')\n    clf.fit(X, Y)\n    assert_array_equal(clf.predict(T), true_result)\n"], "sample_22": ["    def test_capfirst(self):\n        self.assertEqual(text.capfirst('hello'), 'Hello')\n        self.assertEqual(text.capfirst('Hello'), 'Hello')\n        self.assertEqual(text.capfirst(''), '')\n        self.assertEqual(text.capfirst('123'), '123')\n        self.assertEqual(text.capfirst(' hello'), ' hello')\n"]}, "raw_scored_generations": {"sample_0": [false], "sample_2": [false], "sample_3": [true], "sample_1": [false], "sample_6": [true], "sample_4": [true], "sample_5": [false], "sample_7": [false], "sample_9": [false], "sample_8": [true], "sample_10": [true], "sample_11": [true], "sample_13": [false], "sample_12": [false], "sample_14": [false], "sample_15": [true], "sample_16": [false], "sample_17": [false], "sample_18": [false], "sample_19": [false], "sample_21": [false], "sample_20": [false], "sample_23": [false], "sample_22": [true], "sample_24": [true], "sample_25": [false], "sample_28": [false], "sample_26": [false], "sample_27": [false], "sample_29": [false], "sample_31": [false], "sample_30": [false], "sample_32": [false], "sample_33": [false], "sample_34": [false], "sample_35": [false], "sample_36": [true], "sample_37": [true], "sample_39": [true], "sample_38": [true], "sample_40": [false], "sample_42": [true], "sample_41": [false], "sample_43": [false], "sample_45": [false], "sample_44": [false], "sample_46": [false], "sample_48": [false], "sample_47": [true], "sample_50": [false], "sample_49": [false], "sample_51": [false], "sample_52": [false], "sample_53": [false], "sample_55": [true], "sample_54": [false], "sample_56": [false], "sample_58": [true], "sample_57": [true], "sample_60": [false], "sample_59": [true], "sample_61": [false], "sample_63": [false], "sample_62": [false], "sample_64": [false], "sample_66": [true], "sample_65": [false], "sample_68": [true], "sample_67": [true], "sample_69": [true], "sample_70": [false], "sample_71": [true], "sample_72": [true], "sample_73": [false], "sample_74": [false], "sample_75": [false], "sample_76": [false], "sample_77": [false], "sample_78": [false], "sample_79": [true], "sample_80": [false], "sample_82": [false], "sample_81": [true], "sample_83": [false], "sample_84": [false], "sample_85": [false], "sample_86": [false], "sample_87": [false], "sample_88": [true], "sample_89": [false], "sample_90": [false], "sample_91": [false], "sample_92": [false], "sample_93": [true], "sample_95": [false], "sample_94": [true], "sample_96": [false], "sample_97": [true], "sample_98": [true], "sample_99": [false], "sample_100": [true], "sample_101": [true], "sample_102": [true], "sample_103": [false], "sample_104": [true], "sample_105": [false], "sample_107": [false], "sample_106": [true], "sample_108": [true], "sample_109": [true], "sample_110": [false], "sample_111": [false], "sample_112": [true], "sample_113": [false], "sample_114": [true], "sample_115": [true], "sample_116": [false], "sample_117": [false], "sample_118": [false], "sample_119": [true], "sample_120": [false], "sample_121": [false], "sample_122": [true], "sample_123": [false], "sample_124": [false], "sample_125": [false], "sample_126": [false], "sample_127": [false], "sample_128": [false], "sample_129": [false], "sample_130": [false], "sample_131": [true], "sample_132": [false], "sample_133": [false], "sample_134": [false], "sample_135": [true], "sample_136": [false], "sample_137": [true], "sample_138": [true], "sample_139": [false], "sample_140": [true], "sample_142": [true], "sample_141": [false], "sample_143": [false], "sample_144": [true], "sample_145": [false], "sample_146": [false], "sample_147": [true], "sample_148": [true], "sample_149": [true], "sample_150": [false], "sample_151": [true], "sample_152": [true], "sample_153": [false], "sample_154": [true], "sample_155": [false], "sample_156": [true], "sample_157": [false], "sample_158": [false], "sample_159": [false]}}